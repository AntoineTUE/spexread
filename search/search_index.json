{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"spexread","text":"<p>A package for reading Princeton Instruments SPE files captured by WinSpec (version 2.x) or LightField(version 3.0).</p> <p>It relies on <code>xarray</code> to handle the many different possible image shapes, ROIs, etc. that can be stored in an SPE file and reads them into a single <code>xarray.Dataset</code>, or a list of <code>xarray.DataArrays</code>.</p> <p>Important metadata for both format versions is parsed and validated to a consistent schema using <code>pydantic</code> and stored in the <code>attrs</code> attribute of the dataset.</p> <p>This has a number of key benefits:</p> <ul> <li> <p> Data is described and indexed as a function of dimensions or coordinates.</p> </li> <li> <p> Access per-frame tracking information such as <code>exposure_time</code> or <code>gate_width</code> trivially (when stored, SPE v3.0 only) as coordinates of your data, alongside the core dimension <code>x</code>,<code>y</code> and <code>frame</code>.</p> </li> <li> <p> The <code>xarray.Dataset</code> supports multiple regions of interest (ROI's) that can be accessed like a python <code>dict</code>.</p> </li> <li> <p>You can handle files in the same way, regardless of amount of ROI's.</p> </li> <li> <p> Metadata remains closely associated with the data and can be easily accessed.</p> </li> </ul> <p>Important</p> <p><code>spexread</code> is functional, but some features and metadata that you use may be missing. Please file an issue and provide a sample file to add support for them. Found a bug? Please raise an issue as well!</p>"},{"location":"#installing","title":"Installing","text":"<p><code>spexread</code> can be installed easily with <code>pip</code>, from PyPI:</p> <pre><code>pip install spexread\n</code></pre> <p>To install the latest version from GitHub, you can run the following command:</p> <pre><code>pip install git+https://github.com/AntoineTUE/spexread\n</code></pre>"},{"location":"#example-usage","title":"Example usage","text":"<p>The example below demonstrates how to plot a kinetic series.</p> <p>In LightField it is possible to acquire a kinetic series with varying gate width and gate delay, which can be stored to the file.</p> <p>You can change the <code>frame</code> coordinate with e.g. <code>gate_width</code> in this example, to plot as a function of this coordinate.</p> <pre><code>from spexread import read_spe_file\nfrom spexread.data_models import SPEType\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\n\n# read data as a xarray.Dataset\ndata = read_spe_file(Path(\"./my_data.spe\"))\nprint(data.coords._names) # lists available coordinate names\n\n# plot spectra\nplt.figure()\nfor name,roi in data.items():\n    roi.mean(['frame','y']).plot(x='wavelength', label=name)\n\n# Plot trends over time. You can replace `frame` with e.g. `gate_width` as well.\nplt.figure()\nfor name,roi in data.items():\n    roi.mean(['y','x']).plot(x='frame',label=name)\n\n# easily convert to numpy arrays if needed, other formats possible as well, see xarray docs.\nimage = data['ROI 0'].mean('frame').to_numpy()\nplt.figure()\nplt.imshow(image)\n\n# Convert the SPE metadata to a SPEType pydantic model, allowing attribute access\nmetadata = SPEType.model_validate(data.attrs)\nprint(metadata.GeneralInfo)\nprint(metadata.Calibrations.WavelengthCalib)\nprint(metadata.Calibrations.WavelengthCalib.wavelength)\n</code></pre>"},{"location":"#license","title":"License","text":"<p>spexread is licensed under the MIT license.</p>"},{"location":"File_info/","title":"SPE file structure","text":"<p><code>spexread</code> is made to read data from Princeton Instruments SPE files, supporting both the modern format made by LightField (SPE version 3.0) and legacy files created by WinSpec (SPE version 2.x).</p> <p>The main difference between the modern version 3.0 format are:</p> <ul> <li>Structured metadata is stored in an XML footer at the end of the file</li> <li>Each binary <code>Frame</code> block can now contain tracking metadata at the end.</li> </ul> <pre><code>%%{init: { \"theme\":\"neutral\",\"themeVariables\": { \"fontSize\":\"32px\" }}}%%\nblock-beta\ncolumns 3\n  block:File:3\n    Header(\"Binary header\")\n    Binary(\"Binary data\")\n    Footer(\"XML footer\")\n  end\n  Header--&gt; HeaderBlock(\"4100 Bytes\")\n  block:Bin\n    Frame1(\"Frame 0\")\n    Frame2(\"Frame ...\")\n    Frame3(\"Frame N\")\n  end\n  block:XMLMeta\n    FrameInfo\n    Calibrations\n    FrameTrackInfo\n  end\n  Binary --&gt; Bin\n  block:HeaderInfo\n    Frames\n    Dimension\n    XMLOffset\n    etc.\n  end\n  block:Frameblock\n    ROI1(\"ROI 0\")\n    ROI2(\"ROI ...\")\n    Frametrack\n  end\n  Bin --&gt; Frameblock\n  space\n  space\n  block:FrameMeta\n  exsposure_start(\"Exposure start\")\n  exsposure_end(\"Exsposure end\")\n  gate_start(\"Gate start\")\n  gate_end(\"Gate end\")\n  modulation(\"Modulation\")\n  end\n  Frametrack--&gt;FrameMeta</code></pre>"},{"location":"examples/","title":"Examples","text":"In\u00a0[1]: Copied! <pre>from spexread import read_spe_file\nfrom spexread.data_models import SPEType\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\n</pre> from spexread import read_spe_file from spexread.data_models import SPEType from pathlib import Path import matplotlib.pyplot as plt In\u00a0[2]: Copied! <pre>data = read_spe_file(\"../2025 April 15 11_02_25.spe\")\nmeta_data = SPEType.model_validate(data.attrs)\ndata\n</pre> data = read_spe_file(\"../2025 April 15 11_02_25.spe\") meta_data = SPEType.model_validate(data.attrs) data Out[2]: <pre>&lt;xarray.Dataset&gt; Size: 3MB\nDimensions:     (frame: 5, y: 256, x: 1024)\nCoordinates:\n  * frame       (frame) int64 40B 0 1 2 3 4\n  * y           (y) int64 2kB 0 1 2 3 4 5 6 7 ... 249 250 251 252 253 254 255\n  * x           (x) int64 8kB 0 1 2 3 4 5 6 ... 1018 1019 1020 1021 1022 1023\n    wavelength  (x) float64 8kB 331.8 331.9 332.0 332.1 ... 468.2 468.3 468.4\nData variables:\n    ROI 0       (frame, y, x) uint16 3MB 8281 8281 8265 ... 12297 12249 12105\nAttributes:\n    version:       3.0\n    FrameInfo:     {'type': 'Frame', 'count': 5, 'pixelFormat': 'uint16', 'si...\n    MetaFormat:    {'MetaBlock': []}\n    Calibrations:  {'WavelengthCalib': {'id': 1, 'date': datetime.datetime(19...\n    GeneralInfo:   {'creator': 'TUE\\\\s106932', 'created': datetime.datetime(2...</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>frame: 5</li><li>y: 256</li><li>x: 1024</li></ul></li><li>Coordinates: (4)<ul><li>frame(frame)int640 1 2 3 4<pre>array([0, 1, 2, 3, 4])</pre></li><li>y(y)int640 1 2 3 4 5 ... 251 252 253 254 255<pre>array([  0,   1,   2, ..., 253, 254, 255], shape=(256,))</pre></li><li>x(x)int640 1 2 3 4 ... 1020 1021 1022 1023<pre>array([   0,    1,    2, ..., 1021, 1022, 1023], shape=(1024,))</pre></li><li>wavelength(x)float64331.8 331.9 332.0 ... 468.3 468.4<pre>array([331.75149713, 331.88410336, 332.01671504, ..., 468.17564513,\n       468.30848472, 468.4413193 ], shape=(1024,))</pre></li></ul></li><li>Data variables: (1)<ul><li>ROI 0(frame, y, x)uint168281 8281 8265 ... 12249 12105type :Regioncount :1width :1024height :256size :524288stride :524288sensor_mapping :{'id': 3, 'x': 0, 'y': 0, 'height': 256, 'width': 1024, 'xBin': 1, 'yBin': 1}<pre>array([[[ 8281,  8281,  8265, ...,  8265,  8265,  8265],\n        [ 8281,  8265,  8265, ...,  8265,  8265,  8265],\n        [ 8281,  8265,  8265, ...,  8265,  8265,  8265],\n        ...,\n        [ 9673,  9641,  9609, ...,  9353,  9449,  9561],\n        [ 9721,  9673,  9641, ...,  9385,  9497,  9609],\n        [ 9753,  9721,  9673, ...,  9417,  9529,  9641]],\n\n       [[ 8441,  8441,  8425, ...,  8329,  8361,  8409],\n        [ 8441,  8425,  8409, ...,  8329,  8361,  8393],\n        [ 8441,  8425,  8409, ...,  8329,  8361,  8393],\n        ...,\n        [10329, 10297, 10249, ...,  9961, 10073, 10201],\n        [10377, 10329, 10297, ...,  9993, 10121, 10249],\n        [10425, 10377, 10329, ..., 10041, 10169, 10297]],\n\n       [[ 8761,  8745,  8713, ...,  8569,  8633,  8697],\n        [ 8745,  8713,  8697, ...,  8553,  8601,  8665],\n        [ 8745,  8713,  8697, ...,  8553,  8601,  8665],\n        ...,\n        [11065, 11017, 10969, ..., 10649, 10793, 10921],\n        [11113, 11065, 11017, ..., 10697, 10825, 10969],\n        [11161, 11113, 11065, ..., 10745, 10873, 11017]],\n\n       [[ 9225,  9193,  9161, ...,  8953,  9033,  9129],\n        [ 9193,  9161,  9129, ...,  8921,  9001,  9097],\n        [ 9193,  9161,  9129, ...,  8921,  9001,  9097],\n        ...,\n        [11849, 11801, 11753, ..., 11401, 11561, 11705],\n        [11897, 11849, 11801, ..., 11449, 11609, 11753],\n        [11945, 11897, 11849, ..., 11497, 11657, 11801]],\n\n       [[ 9801,  9753,  9721, ...,  9449,  9561,  9673],\n        [ 9753,  9721,  9673, ...,  9417,  9529,  9641],\n        [ 9753,  9721,  9673, ...,  9417,  9529,  9641],\n        ...,\n        [12057, 12105, 12153, ..., 12201, 12345, 12201],\n        [12009, 12057, 12105, ..., 12249, 12297, 12153],\n        [11945, 12009, 12057, ..., 12297, 12249, 12105]]],\n      shape=(5, 256, 1024), dtype=uint16)</pre></li></ul></li><li>Attributes: (5)version :3.0FrameInfo :{'type': 'Frame', 'count': 5, 'pixelFormat': 'uint16', 'size': 524288, 'stride': 524288, 'calibrations': 1, 'metaformat_index': None, 'ROIs': [{'type': 'Region', 'count': 1, 'width': 1024, 'height': 256, 'size': 524288, 'stride': 524288, 'sensor_mapping': {'id': 3, 'x': 0, 'y': 0, 'height': 256, 'width': 1024, 'xBin': 1, 'yBin': 1}}]}MetaFormat :{'MetaBlock': []}Calibrations :{'WavelengthCalib': {'id': 1, 'date': datetime.datetime(1970, 1, 1, 1, 0), 'orientation': 'Normal', 'wavelength': array([331.75149713, 331.88410336, 332.01671504, ..., 468.17564513,        468.30848472, 468.4413193 ], shape=(1024,)), 'coefficients': array([1., 0., 0., 0., 0.])}, 'SensorInformation': {'id': 2, 'orientation': 'Normal', 'width': 1024, 'height': 256}, 'SensorMapping': [{'id': 3, 'x': 0, 'y': 0, 'height': 256, 'width': 1024, 'xBin': 1, 'yBin': 1}]}GeneralInfo :{'creator': 'TUE\\\\s106932', 'created': datetime.datetime(2025, 4, 15, 11, 2, 27, 967440, tzinfo=TzInfo(7200)), 'last_modified': datetime.datetime(2025, 11, 24, 18, 5, 31, 62565), 'notes': ''}</li></ul> In\u00a0[3]: Copied! <pre>by_frames = data[\"ROI 0\"].groupby(\"frame\")\nfig, ax = plt.subplots(len(by_frames), 1, figsize=(3, 12))\nfor index, frame in by_frames:\n    frame.plot(x=\"x\", y=\"y\", ax=ax[index])\n</pre> by_frames = data[\"ROI 0\"].groupby(\"frame\") fig, ax = plt.subplots(len(by_frames), 1, figsize=(3, 12)) for index, frame in by_frames:     frame.plot(x=\"x\", y=\"y\", ax=ax[index]) <p>Instead of directly plotting, you can also aggregate over your data along a <code>dimension</code>, before visualizing.</p> <p>Note: for aggregations etc. you should use only <code>dimensions</code>, not <code>coordinates</code>, as <code>coordinates</code> can depend on multiple <code>dimensions</code>.</p> In\u00a0[21]: Copied! <pre>for index, frame in by_frames:\n    frame.sum(\"y\").plot(x=\"wavelength\", label=f\"frame {index}\")\nplt.title(\"\")\nplt.legend()\nplt.ylabel(\"Counts\")\n</pre> for index, frame in by_frames:     frame.sum(\"y\").plot(x=\"wavelength\", label=f\"frame {index}\") plt.title(\"\") plt.legend() plt.ylabel(\"Counts\") Out[21]: <pre>Text(0, 0.5, 'Counts')</pre>"},{"location":"examples/#examples","title":"Examples\u00b6","text":"<p>These short examples demonstrate how you can use <code>spexread</code> and to read your files into <code>xarray.Datasets</code>.</p> <p>These <code>Dataset</code> objects enable easy analysis and aggregation of data from an <code>SPE</code> file.</p>"},{"location":"examples/#read-a-file-as-a-dataset","title":"Read a file as a dataset\u00b6","text":"<p><code>read_spe_file</code> reads a file as a <code>Dataset</code> unless you specify the keyword argument <code>as_dataset = False</code>, in which case a list of <code>DataArrays</code> will be returned.</p> <p>The metadata from the file willbe stored in the <code>attrs</code> attribute, as a deeply nested dictionary.</p> <p>A more convenient way to work with this metadata, is to read it into the <code>SPEType</code> pydantic model, which let's you traverse it by attribute access.</p> <p>In a notebook, you can easily inspect the contents of a Dataset as shown below.</p>"},{"location":"examples/#plotting-data","title":"Plotting data\u00b6","text":"<p>Datasets behave as if they are dictionary-like containers for Regions-of-Interest, meaning you can access them using a key: <code>ROI 0</code> by default for the first ROI.</p> <p>Each element in the Dataset, is a DataArray, which is akin to a N-dimensional <code>DataFrame</code>.</p> <p>In this case, you access the underlying data, not by a column name, but by the name of a <code>dimension</code> or <code>coordinate</code>.</p> <p>Similarly, you can use <code>groupby</code> operations for aggregation etc.</p> <p>This makes it very easy to iterate over the frames in a ROI and plot them, for instance:</p>"},{"location":"license/","title":"License","text":"<p>MIT LICENCE</p> <p>Copyright \u00a9 2025, Antoine Salden</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"reference/spexread/","title":"spexread","text":""},{"location":"reference/spexread/#spexread","title":"spexread","text":"<p><code>spexread</code> is a module to ingest Priceton Instruments SPE files, recorded with LightField or WinSpec software.</p> <p>It mainly supports SPE files adhering to the version 3.0 or 2.x specification.</p> <p>Older legacy file types can work, but correct (meta)data parsing is not guaranteed.</p> <p>Modules:</p> Name Description <code>data_models</code> <p>Module containing the core data models to describe SPE-file metadata, powered by pydantic for data validation and serialization.</p> <code>parsing</code> <p>Module for handling the parsing of SPE files.</p> <code>structdef</code> <p>Definitions of C structures in the SPE file header.</p> <code>transformation</code> <p>Simple transformations of data for rotation and flipping operations.</p> <p>Functions:</p> Name Description <code>read_spe_file</code> <p>Read an SPE file including metadata from a file path.</p>"},{"location":"reference/spexread/#spexread.read_spe_file","title":"read_spe_file","text":"<pre><code>read_spe_file(file: Path | str, as_dataset=True, strict: bool = False) -&gt; Dataset | list[DataArray]\n</code></pre> <p>Read an SPE file including metadata from a file path.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path | str</code> <p>A file path</p> required <code>as_dataset</code> <code>bool</code> <p>Flag to return either an <code>xarray.Dataset</code> (True) or a list of <code>xarray.DataArray</code> (False). Default: <code>True</code></p> <code>True</code> <code>strict</code> <code>bool</code> <p>Flag to perform validation check on the file using the binary metadata header, potentially detecting invalid/unsupported files. Default: <code>False</code></p> <code>False</code> <p>Returns:</p> Type Description <code>Dataset | list[DataArray]</code> <p>The data per-ROI, as either a joined <code>xarray.Dataset</code>, or a list of <code>xarray.DataArrays</code></p> <p>For more info, refer to the docs for <code>parse_spe_metadata</code> and <code>parse_spe_data</code>.</p> Source code in <code>src/spexread/parsing.py</code> <pre><code>def read_spe_file(file: Path | str, as_dataset=True, strict: bool = False) -&gt; xr.Dataset | list[xr.DataArray]:\n    \"\"\"Read an SPE file including metadata from a file path.\n\n    Args:\n        file (Path|str):        A file path\n        as_dataset (bool):      Flag to return either an `xarray.Dataset` (True) or a list of `xarray.DataArray` (False). Default: `True`\n        strict (bool):          Flag to perform validation check on the file using the binary metadata header, potentially detecting invalid/unsupported files. Default: `False`\n\n    Returns:\n        The data per-ROI, as either a joined `xarray.Dataset`, or a list of `xarray.DataArrays`\n\n    For more info, refer to the docs for [`parse_spe_metadata`][(p).parsing.parse_spe_metadata] and [`parse_spe_data`][(p).parsing.parse_spe_data].\n    \"\"\"\n    file = Path(file)\n    info = parse_spe_metadata(file, strict=strict)\n\n    data_list = parse_spe_data(file, info, with_calibration=not as_dataset)\n    if not as_dataset:\n        return data_list\n    data = xr.combine_by_coords(data_list, join=\"outer\")\n    calib_dim_name, calib_coords, *_ = map_calibration_to_current_coordinate_system(info)\n    try:\n        # coerce to numpy array to avoid ambiguity for xarray\n        _calibrated_pixels = getattr(data, calib_dim_name, data.x).data\n        calib_coords = calib_coords[_calibrated_pixels]  # slice calibration array with current pixels\n    except IndexError:\n        # patch for stitched spectra that extend beyond sensor dimension\n        # TODO: only likely to work for SPE2 files, as SPE3 files store a different calibration\n        calib_coords = polyval(getattr(data, calib_dim_name).data, info.Calibrations.WavelengthCalib.coefficients)\n    data = data.assign_coords(wavelength=(calib_dim_name, calib_coords))\n    data.attrs = info.model_dump()\n    return data\n</code></pre>"},{"location":"reference/spexread/data_models/","title":"data_models","text":""},{"location":"reference/spexread/data_models/#spexread.data_models","title":"spexread.data_models","text":"<p>Module containing the core data models to describe SPE-file metadata, powered by pydantic for data validation and serialization.</p> <p>This ensures that the retrieved metadata will have the same structure and datatypes regardless of the SPE version.</p> <p>The only difference will stem from the fact that the newer SPE v3.0 format supports more information, due to it being more extensible.</p> <p>For older formats, there will be less information available, or fields may simply not be set.</p> <p>In the modelling of the hierarchical structure, the XML structure and SPE v3.0 File Format specification are taken as reference.</p> <p>Classes:</p> Name Description <code>XMLBaseModel</code> <p>Base model for representing XML data.</p> <code>RegionType</code> <p>A model for representing information about a Region Of Interest (ROI).</p> <code>FrameType</code> <p>A model representing information about frames captured by the camera.</p> <code>TrackType</code> <p>A model representing a generic implementation of per-frame tracking metadata, such as gate time.</p> <code>TimeTrackType</code> <p>A model of the <code>TimeStamp</code> XML element that describes the metadata format of exposure events in the binary data blob.</p> <code>GateTrackType</code> <p>A model of the <code>GateTracking</code> XML element that describes the metadata format of gating events in the binary data blob.</p> <code>ModulationTrackType</code> <p>A model of the <code>ModulationTracking</code> XML element that describes the metadata format of RF modulation in the binary data blob.</p> <code>MetaBlockType</code> <p>A model for the <code>MetaBlock</code> XML element that describes the dataformat of per-frame tracking metadata.</p> <code>MetaFormatType</code> <p>A model for the <code>MetaFormat</code> XML element that acts as a container for multiple MetaBlockType models.</p> <code>SensorType</code> <p>A model for information about the camera sensor.</p> <code>SensorMapType</code> <p>A model for mapping ROIs to regions on the sensor.</p> <code>WavelengthCalibType</code> <p>A data model for containing wavelength calibration information.</p> <code>CalibrationsType</code> <p>A model representing calibration data.</p> <code>GeneralInfoType</code> <p>Model for containing general information about the file, such as creation date, etc.</p> <code>SPEType</code> <p>The root datamodel for SPE metadata, based on the SPE v3.0 XML structure.</p> <p>Attributes:</p> Name Type Description <code>NS</code> <p>The default SPE file namespace</p> <code>PRE</code> <p>SPE namespace prefix for use with xpath.</p> <code>NS_EXP</code> <p>Experiment namespace</p> <code>PRE_EXP</code> <p>Experiment namespace prefix</p> <code>dtype_mapping</code> <p>Maps SPE 3.0 datatype strings (without default monochrome suffix) to more conventional dtype names that can be understood by <code>numpy</code>.</p>"},{"location":"reference/spexread/data_models/#spexread.data_models.NS","title":"NS","text":"<pre><code>NS = 'http://www.princetoninstruments.com/spe/2009'\n</code></pre> <p>The default SPE file namespace</p>"},{"location":"reference/spexread/data_models/#spexread.data_models.PRE","title":"PRE","text":"<pre><code>PRE = 'spe'\n</code></pre> <p>SPE namespace prefix for use with xpath.</p>"},{"location":"reference/spexread/data_models/#spexread.data_models.NS_EXP","title":"NS_EXP","text":"<pre><code>NS_EXP = 'http://www.princetoninstruments.com/experiment/2009'\n</code></pre> <p>Experiment namespace</p>"},{"location":"reference/spexread/data_models/#spexread.data_models.PRE_EXP","title":"PRE_EXP","text":"<pre><code>PRE_EXP = 'exp'\n</code></pre> <p>Experiment namespace prefix</p>"},{"location":"reference/spexread/data_models/#spexread.data_models.dtype_mapping","title":"dtype_mapping","text":"<pre><code>dtype_mapping = {'unsigned16': 'uint16', 'unsigned32': 'uint32', 'floating32': 'float32'}\n</code></pre> <p>Maps SPE 3.0 datatype strings (without default monochrome suffix) to more conventional dtype names that can be understood by <code>numpy</code>.</p>"},{"location":"reference/spexread/data_models/#spexread.data_models.XMLBaseModel","title":"XMLBaseModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model for representing XML data.</p> <p>Attributes:</p> Name Type Description <code>ns</code> <code>ClassVar</code> <code>model_config</code>"},{"location":"reference/spexread/data_models/#spexread.data_models.XMLBaseModel.ns","title":"ns","text":"<pre><code>ns: ClassVar = {PRE: NS, PRE_EXP: NS_EXP}\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.XMLBaseModel.model_config","title":"model_config","text":"<pre><code>model_config = ConfigDict(validate_by_name=True, validate_by_alias=True)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.RegionType","title":"RegionType","text":"<p>               Bases: <code>XMLBaseModel</code></p> <p>A model for representing information about a Region Of Interest (ROI).</p> <p>When available, the corresponding <code>SensorMapType</code> for the region will be set as well.</p> <p>This provides additional usefull information such as binning and location of the ROI on the sensor.</p> <p>Methods:</p> Name Description <code>validate_type</code> <p>Validate the <code>type</code> field; only <code>Region</code> is correct.</p> <code>from_xml_node</code> <p>Extract fields from an XML node to create a <code>RegionType</code>.</p> <code>from_struct</code> <p>Create a <code>RegionType</code> model from a SPE C Struct.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <code>count</code> <code>int</code> <code>width</code> <code>int</code> <code>height</code> <code>int</code> <code>size</code> <code>int</code> <code>stride</code> <code>int</code> <code>sensor_mapping</code> <code>Optional[SensorMapType]</code>"},{"location":"reference/spexread/data_models/#spexread.data_models.RegionType.type","title":"type","text":"<pre><code>type: str = Field(repr=False, default='Region')\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.RegionType.count","title":"count","text":"<pre><code>count: int = Field(repr=False, default=1)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.RegionType.width","title":"width","text":"<pre><code>width: int\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.RegionType.height","title":"height","text":"<pre><code>height: int\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.RegionType.size","title":"size","text":"<pre><code>size: int\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.RegionType.stride","title":"stride","text":"<pre><code>stride: int\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.RegionType.sensor_mapping","title":"sensor_mapping","text":"<pre><code>sensor_mapping: Optional[SensorMapType] = Field(repr=False, default=None)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.RegionType.validate_type","title":"validate_type","text":"<pre><code>validate_type(value) -&gt; str\n</code></pre> <p>Validate the <code>type</code> field; only <code>Region</code> is correct.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@field_validator(\"type\", mode=\"after\")\ndef validate_type(cls, value) -&gt; str:\n    \"\"\"Validate the `type` field; only `Region` is correct.\"\"\"\n    if \"Region\" not in value:\n        raise ValueError(f\"{value} is not `Region`, invalid xml object passed\")\n    return value\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.RegionType.from_xml_node","title":"from_xml_node","text":"<pre><code>from_xml_node(node) -&gt; RegionType\n</code></pre> <p>Extract fields from an XML node to create a <code>RegionType</code>.</p> <p>The <code>node</code> must be a <code>DataBlock[@type='Region']</code> element such as retrieved by xpath.</p> <p>For each such block, the corresponding <code>SensorMapping</code> element is retrieved using the <code>id</code> tag.</p> <p>See also <code>SensorMapType</code></p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@classmethod\ndef from_xml_node(cls, node) -&gt; \"RegionType\":\n    \"\"\"Extract fields from an XML node to create a `RegionType`.\n\n    The `node` must be a `DataBlock[@type='Region']` element such as retrieved by xpath.\n\n    For each such block, the corresponding `SensorMapping` element is retrieved using the `id` tag.\n\n    See also [`SensorMapType`][spexread.data_models.SensorMapType]\n    \"\"\"\n    calib_ids = node.attrib[\"calibrations\"].split(\",\")\n    root = node.getroottree()\n    sensor_mapping = SensorMapType(\n        **next(\n            elem[0]\n            for elem in [root.xpath(f\"//{PRE}:SensorMapping[@id='{id}']\", namespaces=cls.ns) for id in calib_ids]\n            if elem != []\n        ).attrib\n    )\n    return RegionType(**node.attrib, sensor_mapping=sensor_mapping)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.RegionType.from_struct","title":"from_struct","text":"<pre><code>from_struct(cstruct: SPEInfoHeader, index: int) -&gt; RegionType\n</code></pre> <p>Create a <code>RegionType</code> model from a SPE C Struct.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@classmethod\ndef from_struct(cls, cstruct: SPEInfoHeader, index: int) -&gt; \"RegionType\":\n    \"\"\"Create a `RegionType` model from a SPE C Struct.\"\"\"\n    dtype_name = EnumDataType(cstruct.datatype).name\n    bitlen = getattr(np, dtype_name)().itemsize\n    width = np.abs(\n        (cstruct.ROIinfblk[index].endx - cstruct.ROIinfblk[index].startx + 1) // cstruct.ROIinfblk[index].groupx\n    )\n    height = np.abs(\n        (cstruct.ROIinfblk[index].endy - cstruct.ROIinfblk[index].starty + 1) // cstruct.ROIinfblk[index].groupy\n    )\n    size = width * height * bitlen\n    return RegionType(\n        width=width, height=height, size=size, stride=size, sensor_mapping=SensorMapType.from_struct(cstruct, index)\n    )\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.FrameType","title":"FrameType","text":"<p>               Bases: <code>XMLBaseModel</code></p> <p>A model representing information about frames captured by the camera.</p> <p>Methods:</p> Name Description <code>validate_type</code> <p>Validate the <code>type</code> field; only <code>Frame</code> is allowed.</p> <code>validate_pixel_format</code> <p>Validate the <code>pixelFormat</code> field, mapping it to a string that can be interpreted as a datatype by numpy.</p> <code>from_xml</code> <p>Create a <code>FrameType</code> model from an XML element.</p> <code>from_struct</code> <p>Create a <code>FrameType</code> model from a C Struct.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <code>count</code> <code>int</code> <code>pixelFormat</code> <code>str</code> <code>size</code> <code>int</code> <code>stride</code> <code>int</code> <code>calibrations</code> <code>int</code> <code>metaformat_index</code> <code>int | None</code> <code>ROIs</code> <code>list[RegionType]</code>"},{"location":"reference/spexread/data_models/#spexread.data_models.FrameType.type","title":"type","text":"<pre><code>type: str = Field(default='Frame', repr=False)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.FrameType.count","title":"count","text":"<pre><code>count: int\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.FrameType.pixelFormat","title":"pixelFormat","text":"<pre><code>pixelFormat: str\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.FrameType.size","title":"size","text":"<pre><code>size: int\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.FrameType.stride","title":"stride","text":"<pre><code>stride: int\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.FrameType.calibrations","title":"calibrations","text":"<pre><code>calibrations: int = Field(default=0)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.FrameType.metaformat_index","title":"metaformat_index","text":"<pre><code>metaformat_index: int | None = Field(default=None, alias='metaFormat')\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.FrameType.ROIs","title":"ROIs","text":"<pre><code>ROIs: list[RegionType] = Field(default=[])\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.FrameType.validate_type","title":"validate_type","text":"<pre><code>validate_type(value: str) -&gt; str\n</code></pre> <p>Validate the <code>type</code> field; only <code>Frame</code> is allowed.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@field_validator(\"type\")\ndef validate_type(cls, value: str) -&gt; str:\n    \"\"\"Validate the `type` field; only `Frame` is allowed.\"\"\"\n    if \"frame\" not in value.lower():\n        raise ValueError(f\"{value} is not `Frame`\")\n    return value\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.FrameType.validate_pixel_format","title":"validate_pixel_format","text":"<pre><code>validate_pixel_format(value: str) -&gt; str\n</code></pre> <p>Validate the <code>pixelFormat</code> field, mapping it to a string that can be interpreted as a datatype by numpy.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@field_validator(\"pixelFormat\")\ndef validate_pixel_format(cls, value: str) -&gt; str:\n    \"\"\"Validate the `pixelFormat` field, mapping it to a string that can be interpreted as a datatype by numpy.\"\"\"\n    value = str(value).lower().replace(\"monochrome\", \"\")\n    if value in dtype_mapping:\n        value = dtype_mapping[value]\n    return value\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.FrameType.from_xml","title":"from_xml","text":"<pre><code>from_xml(element) -&gt; FrameType\n</code></pre> <p>Create a <code>FrameType</code> model from an XML element.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@classmethod\ndef from_xml(cls, element) -&gt; \"FrameType\":\n    \"\"\"Create a `FrameType` model from an XML element.\"\"\"\n    node = element.getroottree().xpath(f\"*/{PRE}:DataBlock[@type='Frame']\", namespaces=cls.ns)[0]\n    return FrameType(\n        **node.attrib,\n        # ROIs=[RegionType(**r.attrib) for r in node.xpath(f\"./{PRE}:DataBlock[@type='Region']\", namespaces=cls.ns)],\n        ROIs=[\n            RegionType.from_xml_node(r) for r in node.xpath(f\"./{PRE}:DataBlock[@type='Region']\", namespaces=cls.ns)\n        ],\n    )\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.FrameType.from_struct","title":"from_struct","text":"<pre><code>from_struct(cstruct: SPEInfoHeader)\n</code></pre> <p>Create a <code>FrameType</code> model from a C Struct.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@classmethod\ndef from_struct(cls, cstruct: SPEInfoHeader):\n    \"\"\"Create a `FrameType` model from a C Struct.\"\"\"\n    dtype_name = EnumDataType(cstruct.datatype).name\n    bitlen = getattr(np, dtype_name)().itemsize\n    size = cstruct.xdim * cstruct.ydim * bitlen\n    pixel_fmt = f\"Monochrome{dtype_name.capitalize()}\"\n    rois = [RegionType.from_struct(cstruct, i) for i in range(cstruct.NumROI)]\n    # stride = size  # No tracking metadata block in legacy format\n    stride = sum([r.stride for r in rois])\n    return FrameType(count=cstruct.NumFrames, pixelFormat=pixel_fmt, size=size, stride=stride, ROIs=rois)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.TrackType","title":"TrackType","text":"<p>               Bases: <code>XMLBaseModel</code></p> <p>A model representing a generic implementation of per-frame tracking metadata, such as gate time.</p> Not supported by SPE v2.x files <p>Since this type of per-frame metadata is not supported by SPE v2.x files, this class and it's children do not implement a <code>from_struct</code> method or similar.</p> <p>Methods:</p> Name Description <code>from_xml_by_attrib</code> <p>Create a <code>TrackType</code> from an XML node, given a tag and attribute.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Annotated[str, StringConstraints(to_lower=True)]</code> <code>bitDepth</code> <code>Annotated[int, Field(repr=False, multiple_of=8)]</code>"},{"location":"reference/spexread/data_models/#spexread.data_models.TrackType.type","title":"type","text":"<pre><code>type: Annotated[str, StringConstraints(to_lower=True)] = Field(repr=False)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.TrackType.bitDepth","title":"bitDepth","text":"<pre><code>bitDepth: Annotated[int, Field(repr=False, multiple_of=8)]\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.TrackType.from_xml_by_attrib","title":"from_xml_by_attrib","text":"<pre><code>from_xml_by_attrib(node, tag, attrib: tuple[str, str])\n</code></pre> <p>Create a <code>TrackType</code> from an XML node, given a tag and attribute.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@classmethod\ndef from_xml_by_attrib(cls, node, tag, attrib: tuple[str, str]):\n    \"\"\"Create a `TrackType` from an XML node, given a tag and attribute.\"\"\"\n    node = node.getroottree().xpath(f\"*/*/{PRE}:{tag}[@{attrib[0]}='{attrib[1]}']\", namespaces=cls.ns)\n    # print(node, f\"*/*/{PRE}:{tag}[@{attrib[0]}='{attrib[1]}']\")\n    if len(node) &lt; 1:\n        return None\n    return cls(**node[0].attrib)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.TimeTrackType","title":"TimeTrackType","text":"<p>               Bases: <code>TrackType</code></p> <p>A model of the <code>TimeStamp</code> XML element that describes the metadata format of exposure events in the binary data blob.</p> <p>The <code>resolution</code> field describes the resolution of the timestamp in ticks-per-second.</p> <p>Attributes:</p> Name Type Description <code>event</code> <code>str</code> <code>resolution</code> <code>int</code> <code>dt</code> <code>datetime</code>"},{"location":"reference/spexread/data_models/#spexread.data_models.TimeTrackType.event","title":"event","text":"<pre><code>event: str\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.TimeTrackType.resolution","title":"resolution","text":"<pre><code>resolution: int = Field(repr=False)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.TimeTrackType.dt","title":"dt","text":"<pre><code>dt: datetime = Field(alias='absoluteTime', default_factory=fromtimestamp(0))\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.GateTrackType","title":"GateTrackType","text":"<p>               Bases: <code>TrackType</code></p> <p>A model of the <code>GateTracking</code> XML element that describes the metadata format of gating events in the binary data blob.</p> <p>Attributes:</p> Name Type Description <code>component</code> <code>str</code> <code>monotonic</code> <code>bool</code>"},{"location":"reference/spexread/data_models/#spexread.data_models.GateTrackType.component","title":"component","text":"<pre><code>component: str\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.GateTrackType.monotonic","title":"monotonic","text":"<pre><code>monotonic: bool\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.ModulationTrackType","title":"ModulationTrackType","text":"<p>               Bases: <code>TrackType</code></p> <p>A model of the <code>ModulationTracking</code> XML element that describes the metadata format of RF modulation in the binary data blob.</p> <p>Attributes:</p> Name Type Description <code>component</code> <code>str</code> <code>monotonic</code> <code>bool</code>"},{"location":"reference/spexread/data_models/#spexread.data_models.ModulationTrackType.component","title":"component","text":"<pre><code>component: str\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.ModulationTrackType.monotonic","title":"monotonic","text":"<pre><code>monotonic: bool\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.MetaBlockType","title":"MetaBlockType","text":"<p>               Bases: <code>XMLBaseModel</code></p> <p>A model for the <code>MetaBlock</code> XML element that describes the dataformat of per-frame tracking metadata.</p> <p>These metadata fields are stored in the binary data blob as the last part of each <code>frame_stride</code>.</p> <p>When particular per-frame information is tracked, the associated model (a subclass of the TrackType model) field can be used to extract this information.</p> <p>In all other cases these fields will be <code>None</code>.</p> Not supported by SPE v2.x files <p>SPE v2.x files do not allow storing per-frame metadata in the binary blob and this information therefore cannot be extracted.</p> <p>For this reason there is no [<code>from_struct</code>] method, as the parent <code>MetaFormatType</code> will be empty.</p> <p>Methods:</p> Name Description <code>from_xml</code> <p>Create a <code>MetaBlockType</code> from an XML element.</p> <p>Attributes:</p> Name Type Description <code>field_order</code> <code>ClassVar</code> <code>id</code> <code>int</code> <code>exposure_start</code> <code>TimeTrackType | None</code> <code>exposure_end</code> <code>TimeTrackType | None</code> <code>frame_track</code> <code>TrackType | None</code> <code>gate_width</code> <code>GateTrackType | None</code> <code>gate_delay</code> <code>GateTrackType | None</code> <code>modulation</code> <code>ModulationTrackType | None</code>"},{"location":"reference/spexread/data_models/#spexread.data_models.MetaBlockType.field_order","title":"field_order","text":"<pre><code>field_order: ClassVar = ('exposure_start', 'exposure_end', 'frame_track', 'gate_width', 'gate_delay', 'modulation')\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.MetaBlockType.id","title":"id","text":"<pre><code>id: int = Field(default=0, ge=0)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.MetaBlockType.exposure_start","title":"exposure_start","text":"<pre><code>exposure_start: TimeTrackType | None = Field(default=None)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.MetaBlockType.exposure_end","title":"exposure_end","text":"<pre><code>exposure_end: TimeTrackType | None = Field(default=None)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.MetaBlockType.frame_track","title":"frame_track","text":"<pre><code>frame_track: TrackType | None = Field(default=None)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.MetaBlockType.gate_width","title":"gate_width","text":"<pre><code>gate_width: GateTrackType | None = Field(default=None)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.MetaBlockType.gate_delay","title":"gate_delay","text":"<pre><code>gate_delay: GateTrackType | None = Field(default=None)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.MetaBlockType.modulation","title":"modulation","text":"<pre><code>modulation: ModulationTrackType | None = Field(default=None)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.MetaBlockType.from_xml","title":"from_xml","text":"<pre><code>from_xml(element, id) -&gt; MetaBlockType\n</code></pre> <p>Create a <code>MetaBlockType</code> from an XML element.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@classmethod\ndef from_xml(cls, element, id) -&gt; \"MetaBlockType\":\n    \"\"\"Create a `MetaBlockType` from an XML element.\"\"\"\n    node = element.getroottree().xpath(f\"/*/*/{PRE}:MetaBlock[@id='{id}']\", namespaces=cls.ns)[0]\n    kwargs = {}\n    kwargs[\"exposure_start\"] = TimeTrackType.from_xml_by_attrib(node, \"TimeStamp\", (\"event\", \"ExposureStarted\"))\n    kwargs[\"exposure_end\"] = TimeTrackType.from_xml_by_attrib(node, \"TimeStamp\", (\"event\", \"ExposureEnded\"))\n    kwargs[\"gate_width\"] = GateTrackType.from_xml_by_attrib(node, \"GateTracking\", (\"component\", \"Width\"))\n    kwargs[\"gate_delay\"] = GateTrackType.from_xml_by_attrib(node, \"GateTracking\", (\"component\", \"Delay\"))\n    return MetaBlockType(\n        **node.attrib,\n        frame_track=TrackType(**node.xpath(f\"./{PRE}:FrameTrackingNumber\", namespaces=cls.ns)[0].attrib),\n        **{k: v for k, v in kwargs.items() if v is not None},\n    )\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.MetaFormatType","title":"MetaFormatType","text":"<p>               Bases: <code>XMLBaseModel</code></p> <p>A model for the <code>MetaFormat</code> XML element that acts as a container for multiple MetaBlockType models.</p> <p>For SPE v3.0 files, per-frame metadata is stored in the binary data block, which can be retrieved based on the <code>MetaBlockType</code> information.</p> <p>There will however only be one <code>MetaFormat</code> element per SPE file.</p> Not supported by SPE v2.x files <p>SPE v2.x files do not store per-frame metadata in the binary block, and this <code>MetaFormatType</code> will be empty.</p> <p>Methods:</p> Name Description <code>from_xml</code> <p>Create a <code>MetaFormatType</code> from an XML element.</p> <code>from_struct</code> <p>Create a <code>MetaFormatType</code> model from a C Struct.</p> <p>Attributes:</p> Name Type Description <code>MetaBlock</code> <code>list[MetaBlockType]</code>"},{"location":"reference/spexread/data_models/#spexread.data_models.MetaFormatType.MetaBlock","title":"MetaBlock","text":"<pre><code>MetaBlock: list[MetaBlockType] = Field(default=[])\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.MetaFormatType.from_xml","title":"from_xml","text":"<pre><code>from_xml(element) -&gt; MetaFormatType\n</code></pre> <p>Create a <code>MetaFormatType</code> from an XML element.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@classmethod\ndef from_xml(cls, element) -&gt; \"MetaFormatType\":\n    \"\"\"Create a `MetaFormatType` from an XML element.\"\"\"\n    nodes = element.getroottree().xpath(f\"/*/{PRE}:MetaFormat\", namespaces=cls.ns)\n    if len(nodes) &lt; 1:\n        return None\n    node = nodes[0]\n    return MetaFormatType(\n        MetaBlock=[\n            MetaBlockType.from_xml(elem, i + 1)\n            for i, elem in enumerate(node.xpath(f\"./{PRE}:MetaBlock\", namespaces=cls.ns))\n        ]\n    )\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.MetaFormatType.from_struct","title":"from_struct","text":"<pre><code>from_struct(cstruct: SPEInfoHeader) -&gt; MetaFormatType\n</code></pre> <p>Create a <code>MetaFormatType</code> model from a C Struct.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@classmethod\ndef from_struct(cls, cstruct: SPEInfoHeader) -&gt; \"MetaFormatType\":\n    \"\"\"Create a `MetaFormatType` model from a C Struct.\"\"\"\n    return MetaFormatType()  # No tracking metadata is stored in header or binary block for legacy files\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.SensorType","title":"SensorType","text":"<p>               Bases: <code>XMLBaseModel</code></p> <p>A model for information about the camera sensor.</p> <p>Methods:</p> Name Description <code>from_struct</code> <p>Create a <code>SensorType</code> model from a C Struct.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <code>orientation</code> <code>str</code> <code>width</code> <code>int</code> <code>height</code> <code>int</code>"},{"location":"reference/spexread/data_models/#spexread.data_models.SensorType.id","title":"id","text":"<pre><code>id: int\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.SensorType.orientation","title":"orientation","text":"<pre><code>orientation: str\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.SensorType.width","title":"width","text":"<pre><code>width: int\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.SensorType.height","title":"height","text":"<pre><code>height: int\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.SensorType.from_struct","title":"from_struct","text":"<pre><code>from_struct(cstruct: SPEInfoHeader) -&gt; SensorType\n</code></pre> <p>Create a <code>SensorType</code> model from a C Struct.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@classmethod\ndef from_struct(cls, cstruct: SPEInfoHeader) -&gt; \"SensorType\":\n    \"\"\"Create a `SensorType` model from a C Struct.\"\"\"\n    name: str = EnumOrientation(cstruct.geometric).name\n    orient = name.replace(\"|\", \",\")\n    return SensorType(id=2, width=cstruct.xDimDet, height=cstruct.yDimDet, orientation=orient)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.SensorMapType","title":"SensorMapType","text":"<p>               Bases: <code>XMLBaseModel</code></p> <p>A model for mapping ROIs to regions on the sensor.</p> <p>Tracks position and binning information.</p> <p>Using the <code>id</code> attribute, it can be matched to the corresponding ROI.</p> <p>See also <code>RegionType.from_xml_node</code></p> <p>Methods:</p> Name Description <code>from_struct</code> <p>Create a <code>SensorMapType</code> model from a C Struct.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <code>x</code> <code>int</code> <code>y</code> <code>int</code> <code>height</code> <code>int</code> <code>width</code> <code>int</code> <code>xBin</code> <code>int</code> <code>yBin</code> <code>int</code>"},{"location":"reference/spexread/data_models/#spexread.data_models.SensorMapType.id","title":"id","text":"<pre><code>id: int = Field(repr=False)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.SensorMapType.x","title":"x","text":"<pre><code>x: int\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.SensorMapType.y","title":"y","text":"<pre><code>y: int\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.SensorMapType.height","title":"height","text":"<pre><code>height: int\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.SensorMapType.width","title":"width","text":"<pre><code>width: int\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.SensorMapType.xBin","title":"xBin","text":"<pre><code>xBin: int = Field(alias='xBinning')\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.SensorMapType.yBin","title":"yBin","text":"<pre><code>yBin: int = Field(alias='yBinning')\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.SensorMapType.from_struct","title":"from_struct","text":"<pre><code>from_struct(cstruct: SPEInfoHeader, index: int) -&gt; SensorMapType\n</code></pre> <p>Create a <code>SensorMapType</code> model from a C Struct.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@classmethod\ndef from_struct(cls, cstruct: SPEInfoHeader, index: int) -&gt; \"SensorMapType\":\n    \"\"\"Create a `SensorMapType` model from a C Struct.\"\"\"\n    roi = cstruct.ROIinfblk[index]\n    # Correct x and y to zero-indexed, and account for inverted order of start vs end.\n    x = roi.startx - 1 if roi.startx &lt; roi.endx else roi.endx - 1\n    y = roi.starty - 1 if roi.starty &lt; roi.endy else roi.endy - 1\n    width = np.abs(roi.endx - roi.startx) + 1\n    height = np.abs(roi.endy - roi.starty) + 1\n    return SensorMapType(\n        id=index + 3,\n        x=x,\n        y=y,\n        height=height,\n        width=width,\n        xBin=roi.groupx,\n        yBin=roi.groupy,\n    )\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.WavelengthCalibType","title":"WavelengthCalibType","text":"<p>               Bases: <code>XMLBaseModel</code></p> <p>A data model for containing wavelength calibration information.</p> <p>Methods:</p> Name Description <code>parse_wavelength</code> <p>Parse string-formatted wavelength arrays to a 1D numpy array of floats.</p> <code>from_xml</code> <p>Create a <code>WavelengthCalibType</code> from an XML element.</p> <code>from_struct</code> <p>Create a <code>WavelengthCalibType</code> model from a C Struct.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <code>date</code> <code>datetime</code> <code>orientation</code> <code>str</code> <code>wavelength</code> <code>NDArray[Shape['* x'], float]</code> <code>coefficients</code> <code>NDArray[Shape['* x'], float]</code>"},{"location":"reference/spexread/data_models/#spexread.data_models.WavelengthCalibType.id","title":"id","text":"<pre><code>id: int = Field(repr=False)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.WavelengthCalibType.date","title":"date","text":"<pre><code>date: datetime = Field(default_factory=lambda: fromtimestamp(0))\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.WavelengthCalibType.orientation","title":"orientation","text":"<pre><code>orientation: str\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.WavelengthCalibType.wavelength","title":"wavelength","text":"<pre><code>wavelength: NDArray[Shape['* x'], float] = Field(repr=False)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.WavelengthCalibType.coefficients","title":"coefficients","text":"<pre><code>coefficients: NDArray[Shape['* x'], float] = Field(default=array([1, 0, 0, 0, 0], dtype=float), repr=False)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.WavelengthCalibType.parse_wavelength","title":"parse_wavelength","text":"<pre><code>parse_wavelength(value: Any) -&gt; NDArray\n</code></pre> <p>Parse string-formatted wavelength arrays to a 1D numpy array of floats.</p> <p>If input <code>value</code> is already a numpy array, it is assumed to be correct already.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@field_validator(\"wavelength\", mode=\"before\")\ndef parse_wavelength(cls, value: Any) -&gt; NDArray:\n    \"\"\"Parse string-formatted wavelength arrays to a 1D numpy array of floats.\n\n    If input `value` is already a numpy array, it is assumed to be correct already.\n    \"\"\"\n    if isinstance(value, np.ndarray):\n        return value\n    return np.array(value.split(\",\")).astype(float)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.WavelengthCalibType.from_xml","title":"from_xml","text":"<pre><code>from_xml(element) -&gt; WavelengthCalibType\n</code></pre> <p>Create a <code>WavelengthCalibType</code> from an XML element.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@classmethod\ndef from_xml(cls, element) -&gt; \"WavelengthCalibType\":\n    \"\"\"Create a `WavelengthCalibType` from an XML element.\"\"\"\n    xpath = element.getroottree().xpath(f\"/*/*/{PRE}:WavelengthMapping\", namespaces=cls.ns)\n    if len(xpath) &lt; 1:\n        return None\n    else:\n        node = xpath[0]\n    wls = node.xpath(\"./spe:Wavelength\", namespaces=cls.ns)[0].text\n    return WavelengthCalibType(**node.attrib, wavelength=wls)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.WavelengthCalibType.from_struct","title":"from_struct","text":"<pre><code>from_struct(cstruct: SPEInfoHeader) -&gt; WavelengthCalibType\n</code></pre> <p>Create a <code>WavelengthCalibType</code> model from a C Struct.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@classmethod\ndef from_struct(cls, cstruct: SPEInfoHeader) -&gt; \"WavelengthCalibType\":\n    \"\"\"Create a `WavelengthCalibType` model from a C Struct.\"\"\"\n    if cstruct.xcalibration.calib_valid == 1:\n        calib_poly = np.array(cstruct.xcalibration.polynom_coeff, dtype=np.double)\n        # pix_num = cstruct.xdim\n        pix_num = cstruct.xDimDet\n    else:\n        calib_poly = np.array(cstruct.ycalibration.polynom_coeff, dtype=np.double)\n        # pix_num = cstruct.ydim\n        pix_num = cstruct.yDimDet\n    wavelength = polyval(np.arange(pix_num), calib_poly)\n\n    # TODO: support y calibration, or other orientation\n    # TODO: Implement support for glued spectra\n    # TODO: expose the calibration polynomial. Note that SPE stores an empirical one, SPE3 one based on spectrometer geometry etc.\n    # TODO: Find a way to support both cass where ROI is smaller than sensor and must be sliced, and when spectrum is stiched and thus larger than detector.\n    return WavelengthCalibType(id=1, orientation=\"Normal\", wavelength=wavelength, coefficients=calib_poly)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.CalibrationsType","title":"CalibrationsType","text":"<p>               Bases: <code>XMLBaseModel</code></p> <p>A model representing calibration data.</p> <p>Contains wavelenght calibration (if present when using a spectrograph), sensor information, and ROI-to-sensor-mapping information.</p> <p>Calibration data is understood to be \"supplemental information associated with a region or frame that does not vary\" (SPE v3.0 Format specification, Teledyne Princeton Intruments).</p> <p>Methods:</p> Name Description <code>from_xml</code> <p>Create a <code>CalibrationsType</code> from an XML element.</p> <code>from_struct</code> <p>Create a <code>CalibrationsType</code> model from a C Struct.</p> <p>Attributes:</p> Name Type Description <code>WavelengthCalib</code> <code>WavelengthCalibType | None</code> <code>SensorInformation</code> <code>SensorType</code> <code>SensorMapping</code> <code>list[SensorMapType]</code> <code>wl</code> <p>Property accessor to the underlying wavelength calibration array.</p>"},{"location":"reference/spexread/data_models/#spexread.data_models.CalibrationsType.WavelengthCalib","title":"WavelengthCalib","text":"<pre><code>WavelengthCalib: WavelengthCalibType | None = Field(alias='WavelengthMapping')\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.CalibrationsType.SensorInformation","title":"SensorInformation","text":"<pre><code>SensorInformation: SensorType\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.CalibrationsType.SensorMapping","title":"SensorMapping","text":"<pre><code>SensorMapping: list[SensorMapType]\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.CalibrationsType.wl","title":"wl","text":"<pre><code>wl\n</code></pre> <p>Property accessor to the underlying wavelength calibration array.</p> <p>If no wavelength calibration array is available, simply returns a range of indices.</p>"},{"location":"reference/spexread/data_models/#spexread.data_models.CalibrationsType.from_xml","title":"from_xml","text":"<pre><code>from_xml(element) -&gt; CalibrationsType\n</code></pre> <p>Create a <code>CalibrationsType</code> from an XML element.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@classmethod\ndef from_xml(cls, element) -&gt; \"CalibrationsType\":\n    \"\"\"Create a `CalibrationsType` from an XML element.\"\"\"\n    node = element.getroottree().xpath(f\"/*/{PRE}:Calibrations\", namespaces=cls.ns)[0]\n    wl_calib = WavelengthCalibType.from_xml(element)\n    sensor_info = SensorType(**node.find(\"SensorInformation\", node.nsmap).attrib)\n    sensor_mapping = [\n        SensorMapType(**elem.attrib) for elem in node.xpath(f\"./{PRE}:SensorMapping\", namespaces=cls.ns)\n    ]\n\n    return CalibrationsType(WavelengthMapping=wl_calib, SensorInformation=sensor_info, SensorMapping=sensor_mapping)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.CalibrationsType.from_struct","title":"from_struct","text":"<pre><code>from_struct(cstruct: SPEInfoHeader) -&gt; CalibrationsType\n</code></pre> <p>Create a <code>CalibrationsType</code> model from a C Struct.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@classmethod\ndef from_struct(cls, cstruct: SPEInfoHeader) -&gt; \"CalibrationsType\":\n    \"\"\"Create a `CalibrationsType` model from a C Struct.\"\"\"\n    return CalibrationsType(\n        WavelengthMapping=WavelengthCalibType.from_struct(cstruct),\n        SensorInformation=SensorType.from_struct(cstruct),\n        SensorMapping=[SensorMapType.from_struct(cstruct, i) for i in range(cstruct.NumROI)],\n    )\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.GeneralInfoType","title":"GeneralInfoType","text":"<p>               Bases: <code>XMLBaseModel</code></p> <p>Model for containing general information about the file, such as creation date, etc.</p> <p>Methods:</p> Name Description <code>from_xml</code> <p>Create a <code>GeneralInfoType</code> from an XML element.</p> <code>from_struct</code> <p>Create a <code>GeneralInfoType</code> model from a C Struct.</p> <p>Attributes:</p> Name Type Description <code>creator</code> <code>str</code> <code>created</code> <code>datetime</code> <code>last_modified</code> <code>datetime</code> <code>notes</code> <code>str</code>"},{"location":"reference/spexread/data_models/#spexread.data_models.GeneralInfoType.creator","title":"creator","text":"<pre><code>creator: str = Field(default='')\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.GeneralInfoType.created","title":"created","text":"<pre><code>created: datetime = Field(default_factory=now)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.GeneralInfoType.last_modified","title":"last_modified","text":"<pre><code>last_modified: datetime = Field(default_factory=now, repr=False)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.GeneralInfoType.notes","title":"notes","text":"<pre><code>notes: str = Field(default='', repr=False)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.GeneralInfoType.from_xml","title":"from_xml","text":"<pre><code>from_xml(element)\n</code></pre> <p>Create a <code>GeneralInfoType</code> from an XML element.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@classmethod\ndef from_xml(cls, element):\n    \"\"\"Create a `GeneralInfoType` from an XML element.\"\"\"\n    node = element.getroottree().xpath(f\"./{PRE}:GeneralInformation\", namespaces=cls.ns)[0]\n    return GeneralInfoType(**node.find(\"FileInformation\", node.nsmap).attrib)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.GeneralInfoType.from_struct","title":"from_struct","text":"<pre><code>from_struct(cstruct: SPEInfoHeader)\n</code></pre> <p>Create a <code>GeneralInfoType</code> model from a C Struct.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@classmethod\ndef from_struct(cls, cstruct: SPEInfoHeader):\n    \"\"\"Create a `GeneralInfoType` model from a C Struct.\"\"\"\n    fmt_time = \"%d%b%Y %H%M%S\"\n    dt_local = datetime.strptime(f\"{cstruct.date.decode()} {cstruct.ExperimentTimeLocal.decode()}\", fmt_time)\n    dt_utc = datetime.strptime(f\"{cstruct.date.decode()} {cstruct.ExperimentTimeUTC.decode()}\", fmt_time)\n    tz = timezone(dt_local - dt_utc)\n    dt_local = dt_local.replace(tzinfo=tz)\n    return GeneralInfoType(created=dt_local, last_modified=dt_local, notes=cstruct.Comments)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.SPEType","title":"SPEType","text":"<p>               Bases: <code>XMLBaseModel</code></p> <p>The root datamodel for SPE metadata, based on the SPE v3.0 XML structure.</p> <p>This model is the top level container for the hierarchic structure of metadata, with support for either SPE v3.0 XML metadata footer, or SPE v2.x metadata structs.</p> <p>In general, it should not be instantiated by the user, but rather be created from either the SPEType.from_xml or SPEType.from_struct class methods.</p> <p>It provides a universal data model and serialization for both data formats, which makes them largely equivalent.</p> <p>Nevertheless, v3.0 files will still support more diverse metadata and ROIs, since the XML footer allows for much more data to be stored.</p> <p>Once an instance of <code>SPEType</code> is created, you can use attribute access to retrieve relevant metadata.</p> <p>If you prefer a dictionary, it is easily converted using the <code>model_dump()</code> method, and vice-versa via <code>SPEType.model_validate(my_dict)</code>.</p> SPE v3.0 support <p>While many properties relevant to the acquisition of data are supported, the <code>Experiment</code> XML element is not yet supported.</p> <p>This element contains the full LightField setup used for an experiment and is deeply nested.</p> <p>This makes parsing it with models inconvenient, plus, quite a bit of the contained information is redundant.</p> <p>Methods:</p> Name Description <code>from_xml</code> <p>Create a <code>SPEType</code> model from an XML root node.</p> <code>from_struct</code> <p>Create a <code>SPEType</code> model from a C Struct.</p> <p>Attributes:</p> Name Type Description <code>version</code> <code>float</code> <code>FrameInfo</code> <code>FrameType</code> <code>MetaFormat</code> <code>MetaFormatType | None</code> <code>Calibrations</code> <code>CalibrationsType | None</code> <code>GeneralInfo</code> <code>GeneralInfoType</code>"},{"location":"reference/spexread/data_models/#spexread.data_models.SPEType.version","title":"version","text":"<pre><code>version: float\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.SPEType.FrameInfo","title":"FrameInfo","text":"<pre><code>FrameInfo: FrameType\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.SPEType.MetaFormat","title":"MetaFormat","text":"<pre><code>MetaFormat: MetaFormatType | None = Field(default=MetaFormatType())\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.SPEType.Calibrations","title":"Calibrations","text":"<pre><code>Calibrations: CalibrationsType | None = Field(default=None)\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.SPEType.GeneralInfo","title":"GeneralInfo","text":"<pre><code>GeneralInfo: GeneralInfoType = Field(default=GeneralInfoType())\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.SPEType.from_xml","title":"from_xml","text":"<pre><code>from_xml(root)\n</code></pre> <p>Create a <code>SPEType</code> model from an XML root node.</p> <p>It traverses the XML document starting from the root node to build the model.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@classmethod\ndef from_xml(cls, root):\n    \"\"\"Create a `SPEType` model from an XML root node.\n\n    It traverses the XML document starting from the root node to build the model.\n    \"\"\"\n    base = root.xpath(f\"/{PRE}:SpeFormat\", namespaces=cls.ns)[0]\n    frame_info = FrameType.from_xml(base)\n    kwargs = {}\n    kwargs[\"MetaFormat\"] = MetaFormatType.from_xml(base)\n    kwargs[\"Calibrations\"] = CalibrationsType.from_xml(base)\n    kwargs[\"GeneralInfo\"] = GeneralInfoType.from_xml(base)\n    return SPEType(**base.attrib, FrameInfo=frame_info, **{k: v for k, v in kwargs.items() if v is not None})\n</code></pre>"},{"location":"reference/spexread/data_models/#spexread.data_models.SPEType.from_struct","title":"from_struct","text":"<pre><code>from_struct(cstruct: SPEInfoHeader) -&gt; SPEType\n</code></pre> <p>Create a <code>SPEType</code> model from a C Struct.</p> Source code in <code>src/spexread/data_models.py</code> <pre><code>@classmethod\ndef from_struct(cls, cstruct: SPEInfoHeader) -&gt; \"SPEType\":\n    \"\"\"Create a `SPEType` model from a C Struct.\"\"\"\n    return SPEType(\n        version=cstruct.file_header_ver,\n        FrameInfo=FrameType.from_struct(cstruct),\n        MetaFormat=MetaFormatType.from_struct(cstruct),\n        Calibrations=CalibrationsType.from_struct(cstruct),\n        GeneralInfo=GeneralInfoType.from_struct(cstruct),\n    )\n</code></pre>"},{"location":"reference/spexread/parsing/","title":"parsing","text":""},{"location":"reference/spexread/parsing/#spexread.parsing","title":"spexread.parsing","text":"<p>Module for handling the parsing of SPE files.</p> <p>SPE files have a binary header that contains the offset in the file where the actual data starts.</p> <p>Depending on the SPE file version format, this header can contain more elaborate metadata (legacy SPE v2.x) format, or an offset for a flexible XML footer (for SPE v3.0).</p> <p>All SPE files use a 4100 byte header for storing metadata, though for SPE v3.0 files this is mainly intended to retrieve the offset for the XML footer that contains rich metadata.</p> <p>Based on the information obtained from the header and (optional) footer, the actual data per ROI and frame is read from the file, along with optional per-frame tracking metadata (e.g. exposure time, gate delay).</p> <p>Classes:</p> Name Description <code>SPEValidationError</code> <p>Exception raised when validating SPE files in <code>strict</code> mode fails.</p> <p>Functions:</p> Name Description <code>parse_spe_metadata</code> <p>Retrieve header and/or footer metadata for processing <code>*.SPE</code> files.</p> <code>parse_spe_data</code> <p>Parse the data contents of an <code>*.SPE</code> file using the metadata from the header and/or footer.</p> <code>read_spe_file</code> <p>Read an SPE file including metadata from a file path.</p> <p>Attributes:</p> Name Type Description <code>FilePathOrBinaryBuffer</code> <p>Type definition for functions that can accept either a file path, or a file handle (openend in binary mode).</p>"},{"location":"reference/spexread/parsing/#spexread.parsing.FilePathOrBinaryBuffer","title":"FilePathOrBinaryBuffer","text":"<pre><code>FilePathOrBinaryBuffer = str | Path | BinaryIO\n</code></pre> <p>Type definition for functions that can accept either a file path, or a file handle (openend in binary mode).</p>"},{"location":"reference/spexread/parsing/#spexread.parsing.SPEValidationError","title":"SPEValidationError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when validating SPE files in <code>strict</code> mode fails.</p> <p>Files that cause this exception to be raised, may not adhere to the SPE v2.x or SPE 3.0 specifition. Or at least be different than what is documented in the SPE 3.0 specification about legacy compatibility.</p> <p>Attempting to read these files with <code>strict</code> set to <code>False</code> may still result in them being read correctly.</p>"},{"location":"reference/spexread/parsing/#spexread.parsing._parse_xml_footer","title":"_parse_xml_footer","text":"<pre><code>_parse_xml_footer(buff: BufferedReader, offset: int) -&gt; etree\n</code></pre> <p>Parse the XML footer from a file, by reading from the position <code>offset</code> in the file.</p> <p>This offset can be found by reading the file header into an <code>SPEInfoHeader</code>, with the <code>XMLOffset</code> attribute.</p> <p>This will only work for SPE v3.0 files, since the <code>XMLOffset</code> field is not defined for older file formats.</p> <p>Because of this, it will only make sense to use this function if you know you are dealing with a file that has an xml footer.</p> Source code in <code>src/spexread/parsing.py</code> <pre><code>def _parse_xml_footer(buff: \"BufferedReader\", offset: int) -&gt; etree:\n    \"\"\"Parse the XML footer from a file, by reading from the position `offset` in the file.\n\n    This offset can be found by reading the file header into an [`SPEInfoHeader`][spexread.structdef.SPEInfoHeader], with the `XMLOffset` attribute.\n\n    This will only work for SPE v3.0 files, since the `XMLOffset` field is not defined for older file formats.\n\n    Because of this, it will only make sense to use this function if you know you are dealing with a file that has an xml footer.\n    \"\"\"\n    buff.seek(offset)\n    return etree.fromstring(buff.readline())\n</code></pre>"},{"location":"reference/spexread/parsing/#spexread.parsing._parse_ROI","title":"_parse_ROI","text":"<pre><code>_parse_ROI(file: FilePathOrBinaryBuffer, info_header: SPEType, roi_idx: int) -&gt; ndarray\n</code></pre> <p>Retrieve all frames recorded with the same Region Of Interest (ROI) on the camera sensor.</p> <p>Uses a <code>SPEType</code> model containing metadata extracted from the file header and (optional) footer to find chunks of data in the file.</p> <p><code>SPE</code> files store frames as a contiguous block of data, where each frame consists of one or more ROI data block, followed by an optional per-frame tracking data block.</p> <p>To parse this metadata see _parse_tracked_metadata.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path | str</code> <p>A path to a file</p> required <code>info_header</code> <code>SPEType</code> <p>A metadata model containing file metadata, backed by <code>pydantic</code></p> required <code>roi_idx</code> <code>int</code> <p>Index of the ROI to extract, starting from 0.</p> required Source code in <code>src/spexread/parsing.py</code> <pre><code>def _parse_ROI(file: FilePathOrBinaryBuffer, info_header: SPEType, roi_idx: int) -&gt; np.ndarray:\n    \"\"\"Retrieve all frames recorded with the same Region Of Interest (ROI) on the camera sensor.\n\n    Uses a `SPEType` model containing metadata extracted from the file header and (optional) footer to find chunks of data in the file.\n\n    `SPE` files store frames as a contiguous block of data, where each frame consists of one or more ROI data block, followed by an optional per-frame tracking data block.\n\n    To parse this metadata see [_parse_tracked_metadata][..].\n\n    Args:\n        file (Path|str):        A path to a file\n        info_header (SPEType):  A metadata model containing file metadata, backed by `pydantic`\n        roi_idx (int):          Index of the ROI to extract, starting from 0.\n    \"\"\"\n    roi = info_header.FrameInfo.ROIs[roi_idx]\n    dtype = np.dtype(info_header.FrameInfo.pixelFormat.lower().replace(\"monochrome\", \"\"))\n    start = HEADERSIZE + sum([r.stride for r in info_header.FrameInfo.ROIs[:roi_idx]])\n    end = HEADERSIZE + (info_header.FrameInfo.count) * info_header.FrameInfo.stride\n    offset = np.arange(start, end, info_header.FrameInfo.stride)\n    data = np.zeros(roi.size // dtype.itemsize * info_header.FrameInfo.count, dtype=dtype)\n    element_count = roi.stride // dtype.itemsize\n    for frame_idx in range(info_header.FrameInfo.count):\n        start_index = frame_idx * roi.stride // dtype.itemsize\n        stop_index = (frame_idx + 1) * roi.stride // dtype.itemsize\n        data[start_index:stop_index] = np.fromfile(file, dtype=dtype, count=element_count, offset=offset[frame_idx])\n    return data\n</code></pre>"},{"location":"reference/spexread/parsing/#spexread.parsing._parse_tracked_metadata","title":"_parse_tracked_metadata","text":"<pre><code>_parse_tracked_metadata(file_path: Path | str, info: SPEType) -&gt; dict[str, ndarray]\n</code></pre> <p>Extract all available per-frame tracking metadata.</p> <p>This metadata is stored at the end of each frame datablock in an SPE file and varies in length depending on the enabled tracking information in LightField.</p> <p>Which properties are tracked (and their datatype/bitlength) are extracted from the first <code>MetaBlock</code> metadata element.</p> Not supported by SPE v2.x files <p>This only works for SPE v3.0 files, legacy files don't store this information.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path | str</code> <p>A file path</p> required <code>info</code> <code>SPEType</code> <p>A metadata model containing file metadata, backed by <code>pydantic</code></p> required Source code in <code>src/spexread/parsing.py</code> <pre><code>def _parse_tracked_metadata(file_path: Path | str, info: SPEType) -&gt; dict[str, np.ndarray]:\n    \"\"\"Extract all available per-frame tracking metadata.\n\n    This metadata is stored at the end of each frame datablock in an SPE file and varies in length depending on the enabled tracking information in LightField.\n\n    Which properties are tracked (and their datatype/bitlength) are extracted from the first [`MetaBlock`][(p).data_models.MetaBlockType] metadata element.\n\n    Note: Not supported by SPE v2.x files\n        This only works for SPE v3.0 files, legacy files don't store this information.\n\n    Args:\n        file_path (Path|str): A file path\n        info (SPEType): A metadata model containing file metadata, backed by `pydantic`\n    \"\"\"\n    file_path = Path(file_path) if isinstance(file_path, str) else file_path\n    block_offset = sum([r.stride for r in info.FrameInfo.ROIs])\n    tracked_fields = sorted(\n        set(info.MetaFormat.MetaBlock[0].field_order) &amp; info.MetaFormat.MetaBlock[0].model_fields_set,\n        key=lambda x: info.MetaFormat.MetaBlock[0].field_order.index(x),\n    )\n    field_offset = 0\n    tracked = {}\n    with file_path.open(\"rb\") as fo:\n        for field in tracked_fields:\n            field_model = getattr(info.MetaFormat.MetaBlock[0], field)\n            dtype = np.dtype(field_model.type)\n            resolution = getattr(field_model, \"resolution\", 1)\n            offsets = np.arange(\n                start=HEADERSIZE + block_offset + field_offset,\n                stop=HEADERSIZE + info.FrameInfo.stride * info.FrameInfo.count,\n                step=info.FrameInfo.stride,\n                dtype=int,\n            )\n            b = b\"\"\n            for offset in offsets:\n                fo.seek(offset)\n                b += fo.read(dtype.itemsize)\n            tracked[field] = np.frombuffer(b, dtype=dtype) / resolution\n            field_offset += dtype.itemsize\n    return tracked\n</code></pre>"},{"location":"reference/spexread/parsing/#spexread.parsing._spe_metadata_from_buffer","title":"_spe_metadata_from_buffer","text":"<pre><code>_spe_metadata_from_buffer(buff: BinaryIO, strict: bool = False) -&gt; SPEType\n</code></pre> <p>Retrieve header and/or footer metadata from an opened file handle.</p> <p>Low-level method for parse_spe_metadata for already opened file objects.</p> <p>When using <code>strict=True</code>, some fields from the binary header are checked to have certain values. This serves as an early-warning for files that may be corrupt, or maybe not supported.</p> <p>Parameters:</p> Name Type Description Default <code>buff</code> <code>BinaryIO</code> <p>A file-handle or buffer opened in binary mode.</p> required <code>strict</code> <code>bool</code> <p>A flag to force validation of the file by checking some fields in the binary header.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SPEType</code> <code>SPEType</code> <p>A hierarchical model of the metadata.</p> Source code in <code>src/spexread/parsing.py</code> <pre><code>def _spe_metadata_from_buffer(buff: BinaryIO, strict: bool = False) -&gt; SPEType:\n    \"\"\"Retrieve header and/or footer metadata from an opened file handle.\n\n    Low-level method for [parse_spe_metadata][..] for already opened file objects.\n\n    When using `strict=True`, some fields from the binary header are checked to have certain values.\n    This serves as an early-warning for files that may be corrupt, or maybe not supported.\n\n    Args:\n        buff (BinaryIO):    A file-handle or buffer opened in binary mode.\n        strict (bool):      A flag to force validation of the file by checking some fields in the binary header.\n\n    Returns:\n        SPEType:            A hierarchical model of the metadata.\n\n    \"\"\"\n    header = SPEInfoHeader()\n    buff.readinto(header)\n    if strict:\n        for attr, correct in zip([\"WinView_id\", \"lastvalue\", \"lnoscan\"], [WINVIEW_ID, LASTVALUE, -1]):  # noqa: B905\n            actual = getattr(header, attr)\n            if actual != correct:\n                raise SPEValidationError(\n                    f\"Error validating file header for {attr}, expected {correct}, but got {actual}. Try reading this file with `strict` set to `False`.\"\n                )\n    metadata = (\n        SPEType.from_xml(_parse_xml_footer(buff, header.XMLOffset))\n        if header.file_header_ver &gt;= 3\n        else SPEType.from_struct(header)\n    )\n    return metadata\n</code></pre>"},{"location":"reference/spexread/parsing/#spexread.parsing.parse_spe_metadata","title":"parse_spe_metadata","text":"<pre><code>parse_spe_metadata(f: Path | str, strict: bool = False) -&gt; SPEType\n</code></pre> <p>Retrieve header and/or footer metadata for processing <code>*.SPE</code> files.</p> <p>All SPE files start with a 4100 byte header, which contains the offset to the binary data blob as well as optional further metadata, depending on the file version.</p> <p>For SPE v3.0 files, further metadata is extracted from the XML footer, while for older formats it is extracted from the header struct.</p> <p>In both cases a <code>SPEType</code> data model (backed by pydantic for validation and serialization) is returned.</p> <p>This <code>SPEType</code> contains most relevant metadata and the required information to parse the binary data blob to extract per-ROI and per-frame data and associated (optional) per-frame metadata.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Path | str</code> <p>A file path.</p> required <code>strict</code> <code>bool</code> <p>Force strict parsing, meaning some validity checks are performed, default=False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SPEType</code> <code>SPEType</code> <p>A <code>pydantic</code> model of metadata contained in the header and footer of the file.</p> Note <p>This is a convencience function to read from a file, all actual reading happens by the low-level _spe_metadata_from_buffer function from an opened file object.</p> Source code in <code>src/spexread/parsing.py</code> <pre><code>def parse_spe_metadata(f: Path | str, strict: bool = False) -&gt; SPEType:\n    \"\"\"Retrieve header and/or footer metadata for processing `*.SPE` files.\n\n    All SPE files start with a 4100 byte header, which contains the offset to the binary data blob as well as optional further metadata, depending on the file version.\n\n    For SPE v3.0 files, further metadata is extracted from the XML footer, while for older formats it is extracted from the header struct.\n\n    In both cases a [`SPEType`][spexread.data_models.SPEType] data model (backed by [pydantic](https://docs.pydantic.dev) for validation and serialization) is returned.\n\n    This `SPEType` contains most relevant metadata and the required information to parse the binary data blob to extract per-ROI and per-frame data and associated (optional) per-frame metadata.\n\n    Args:\n        f (Path|str): A file path.\n        strict (bool, optional): Force strict parsing, meaning some validity checks are performed, default=False.\n\n    Returns:\n        SPEType                     : A `pydantic` model of metadata contained in the header and footer of the file.\n\n    Note:\n        This is a convencience function to read from a file, all actual reading happens by the low-level [_spe_metadata_from_buffer][..] function from an opened file object.\n    \"\"\"\n    f = Path(f)\n    with f.open(\"rb\") as fo:\n        metadata = _spe_metadata_from_buffer(fo, strict=strict)\n    return metadata\n</code></pre>"},{"location":"reference/spexread/parsing/#spexread.parsing.parse_spe_data","title":"parse_spe_data","text":"<pre><code>parse_spe_data(f: Path, info: SPEType, with_calibration=True) -&gt; list[DataArray]\n</code></pre> <p>Parse the data contents of an <code>*.SPE</code> file using the metadata from the header and/or footer.</p> <p>Will return a list of <code>DataArray</code>, with each element corresponding to a Region of Interest (ROI).</p> <p>When per-frame metadata blocks are encountered (based on <code>SPEType.MetaFormat.MetaBlock</code>) these will be parsed as additional coordinates, containing e.g. the frame number, gate delay or exposure time.</p> <p>In case <code>with_calibration=True</code>, the wavelenght calibration (if known) will be extracted from the file and added to each DataArray.</p> <p>In doing so, we attempt to account for differences in binning and a potential change of orientation of the sensor w.r.t. when the calibration was performed.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Path</code> <p>A file path</p> required <code>info</code> <code>SPEType</code> <p>A metadata model containing file metadata, backed by <code>pydantic</code></p> required Source code in <code>src/spexread/parsing.py</code> <pre><code>def parse_spe_data(f: Path, info: SPEType, with_calibration=True) -&gt; list[xr.DataArray]:\n    \"\"\"Parse the data contents of an `*.SPE` file using the metadata from the header and/or footer.\n\n    Will return a list of `DataArray`, with each element corresponding to a Region of Interest (ROI).\n\n    When per-frame metadata blocks are encountered (based on `SPEType.MetaFormat.MetaBlock`) these will be parsed as additional coordinates, containing e.g. the frame number, gate delay or exposure time.\n\n    In case `with_calibration=True`, the wavelenght calibration (if known) will be extracted from the file and added to each DataArray.\n\n    In doing so, we attempt to account for differences in binning and a potential change of orientation of the sensor w.r.t. when the calibration was performed.\n\n    Args:\n        f (Path): A file path\n        info (SPEType): A metadata model containing file metadata, backed by `pydantic`\n    \"\"\"\n    data_arrays = []\n\n    orient_calib = parse_orientation(\n        info.Calibrations.WavelengthCalib.orientation if info.Calibrations.WavelengthCalib is not None else \"Normal\"\n    )\n    calib_order = apply_transformations(\"x\", \"y\", *orient_calib)  # assume 0th index is calibration axis\n    orient_sensor = parse_orientation(info.Calibrations.SensorInformation.orientation)\n    # Compute transformation to map calibration to current orientation\n    transform = transformation_mapping(orient_calib, orient_sensor)\n    dim_order = apply_transformations(\"y\", \"x\", *transform)  # Flipped, default order ('frame', 'y','x')\n    tracking_data = _parse_tracked_metadata(f, info) if info.FrameInfo.metaformat_index is not None else {}\n\n    for roi_idx, roi in enumerate(info.FrameInfo.ROIs):\n        data = _parse_ROI(f, info, roi_idx)\n        if roi_idx &lt; len(info.Calibrations.SensorMapping):\n            roi_map = info.Calibrations.SensorMapping[roi_idx]\n            coord_order = dict(\n                zip(\n                    dim_order,\n                    [\n                        np.arange(roi_map.y, roi_map.y + roi_map.height, roi_map.yBin) + roi_map.yBin // 2,\n                        np.arange(roi_map.x, roi_map.x + roi_map.width, roi_map.xBin) + roi_map.xBin // 2,\n                    ],\n                    strict=True,\n                )\n            )\n        else:\n            coord_order = dict(zip(dim_order, [np.arange(roi.height), np.arange(roi.width)], strict=True))\n\n        roi_array = xr.DataArray(\n            data.reshape(info.FrameInfo.count, roi.height, roi.width),\n            dims=(\"frame\", *dim_order),\n            coords={\n                \"frame\": np.arange(info.FrameInfo.count),\n                **coord_order,\n            },\n            attrs=info.FrameInfo.ROIs[roi_idx].model_dump(),\n            name=f\"ROI {roi_idx}\",\n        )\n        roi_array = roi_array.assign_coords(**{k: (\"frame\", v) for k, v in tracking_data.items()})\n        if with_calibration:\n            try:\n                calib_coords = info.Calibrations.wl[getattr(roi_array, calib_order[0])]\n            except IndexError:\n                calib_coords = polyval(\n                    getattr(roi_array, calib_order[0]).data, info.Calibrations.WavelengthCalib.coefficients\n                )\n            roi_array = roi_array.assign_coords(wavelength=(calib_order[0], calib_coords))\n        data_arrays.append(roi_array)\n    return data_arrays\n</code></pre>"},{"location":"reference/spexread/parsing/#spexread.parsing.read_spe_file","title":"read_spe_file","text":"<pre><code>read_spe_file(file: Path | str, as_dataset=True, strict: bool = False) -&gt; Dataset | list[DataArray]\n</code></pre> <p>Read an SPE file including metadata from a file path.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path | str</code> <p>A file path</p> required <code>as_dataset</code> <code>bool</code> <p>Flag to return either an <code>xarray.Dataset</code> (True) or a list of <code>xarray.DataArray</code> (False). Default: <code>True</code></p> <code>True</code> <code>strict</code> <code>bool</code> <p>Flag to perform validation check on the file using the binary metadata header, potentially detecting invalid/unsupported files. Default: <code>False</code></p> <code>False</code> <p>Returns:</p> Type Description <code>Dataset | list[DataArray]</code> <p>The data per-ROI, as either a joined <code>xarray.Dataset</code>, or a list of <code>xarray.DataArrays</code></p> <p>For more info, refer to the docs for <code>parse_spe_metadata</code> and <code>parse_spe_data</code>.</p> Source code in <code>src/spexread/parsing.py</code> <pre><code>def read_spe_file(file: Path | str, as_dataset=True, strict: bool = False) -&gt; xr.Dataset | list[xr.DataArray]:\n    \"\"\"Read an SPE file including metadata from a file path.\n\n    Args:\n        file (Path|str):        A file path\n        as_dataset (bool):      Flag to return either an `xarray.Dataset` (True) or a list of `xarray.DataArray` (False). Default: `True`\n        strict (bool):          Flag to perform validation check on the file using the binary metadata header, potentially detecting invalid/unsupported files. Default: `False`\n\n    Returns:\n        The data per-ROI, as either a joined `xarray.Dataset`, or a list of `xarray.DataArrays`\n\n    For more info, refer to the docs for [`parse_spe_metadata`][(p).parsing.parse_spe_metadata] and [`parse_spe_data`][(p).parsing.parse_spe_data].\n    \"\"\"\n    file = Path(file)\n    info = parse_spe_metadata(file, strict=strict)\n\n    data_list = parse_spe_data(file, info, with_calibration=not as_dataset)\n    if not as_dataset:\n        return data_list\n    data = xr.combine_by_coords(data_list, join=\"outer\")\n    calib_dim_name, calib_coords, *_ = map_calibration_to_current_coordinate_system(info)\n    try:\n        # coerce to numpy array to avoid ambiguity for xarray\n        _calibrated_pixels = getattr(data, calib_dim_name, data.x).data\n        calib_coords = calib_coords[_calibrated_pixels]  # slice calibration array with current pixels\n    except IndexError:\n        # patch for stitched spectra that extend beyond sensor dimension\n        # TODO: only likely to work for SPE2 files, as SPE3 files store a different calibration\n        calib_coords = polyval(getattr(data, calib_dim_name).data, info.Calibrations.WavelengthCalib.coefficients)\n    data = data.assign_coords(wavelength=(calib_dim_name, calib_coords))\n    data.attrs = info.model_dump()\n    return data\n</code></pre>"},{"location":"reference/spexread/structdef/","title":"structdef","text":""},{"location":"reference/spexread/structdef/#spexread.structdef","title":"spexread.structdef","text":"<p>Definitions of C structures in the SPE file header.</p> <p>The format of these structures is based on the legacy SPE v2.5 header format specification (from 2004/03/23).</p> <p>Note that even older header formats (namely v1.43 and v1.6) will be compatible for the most part as they use the same 4100 byte header size, but will have occasional different fields.</p> <p>As such, reading data is backwards compatible, but the available metadata should not be considered fully compatible.</p> <p>In case you really need support for these ancient formats, refer to the WinView/WinSpec manuals for changes.</p>"},{"location":"reference/spexread/structdef/#spexread.structdef.EnumDataType","title":"EnumDataType","text":"<p>Enum for data types of recorded data.</p>"},{"location":"reference/spexread/structdef/#spexread.structdef.EnumDataType.float32","title":"float32","text":"<pre><code>float32 = 0\n</code></pre>"},{"location":"reference/spexread/structdef/#spexread.structdef.EnumDataType.int32","title":"int32","text":"<pre><code>int32 = 1\n</code></pre>"},{"location":"reference/spexread/structdef/#spexread.structdef.EnumDataType.int16","title":"int16","text":"<pre><code>int16 = 2\n</code></pre>"},{"location":"reference/spexread/structdef/#spexread.structdef.EnumDataType.uint16","title":"uint16","text":"<pre><code>uint16 = 3\n</code></pre>"},{"location":"reference/spexread/structdef/#spexread.structdef.EnumDataType.float64","title":"float64","text":"<pre><code>float64 = 5\n</code></pre>"},{"location":"reference/spexread/structdef/#spexread.structdef.EnumDataType.int8","title":"int8","text":"<pre><code>int8 = 6\n</code></pre>"},{"location":"reference/spexread/structdef/#spexread.structdef.EnumDataType.uint8","title":"uint8","text":"<pre><code>uint8 = 7\n</code></pre>"},{"location":"reference/spexread/structdef/#spexread.structdef.EnumDataType.uint32","title":"uint32","text":"<pre><code>uint32 = 8\n</code></pre>"},{"location":"reference/spexread/structdef/#spexread.structdef.EnumOrientation","title":"EnumOrientation","text":"<p>Enum for camera sensor orientation.</p>"},{"location":"reference/spexread/structdef/#spexread.structdef.EnumOrientation.Normal","title":"Normal","text":"<pre><code>Normal = 0\n</code></pre>"},{"location":"reference/spexread/structdef/#spexread.structdef.EnumOrientation.Rotate","title":"Rotate","text":"<pre><code>Rotate = 1\n</code></pre>"},{"location":"reference/spexread/structdef/#spexread.structdef.EnumOrientation.Horizontal","title":"Horizontal","text":"<pre><code>Horizontal = 2\n</code></pre>"},{"location":"reference/spexread/structdef/#spexread.structdef.EnumOrientation.Vertical","title":"Vertical","text":"<pre><code>Vertical = 4\n</code></pre>"},{"location":"reference/spexread/structdef/#spexread.structdef.SPEStructure","title":"SPEStructure","text":"<p>A generic class for a C structure that can be converted to a dictionary.</p>"},{"location":"reference/spexread/structdef/#spexread.structdef.SPEStructure.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert a C structure to a dictionary, applying type coercion for nested data types such as structures and arrays.</p> Source code in <code>src/spexread/structdef.py</code> <pre><code>def to_dict(self):\n    \"\"\"Convert a C structure to a dictionary, applying type coercion for nested data types such as structures and arrays.\"\"\"\n    content = {}\n    for k in self._fields_:\n        v = getattr(self, k[0])\n        if isinstance(v, SPEStructure):\n            v = v.to_dict()\n        elif isinstance(v, ctypes.Array):\n            elemType = k[1]._type_\n            if elemType == c_char:\n                v = bytes(v).decode(\"utf-8\", errors=\"ignore\").rstrip(\"\\x00\")\n            elif elemType == c_byte:\n                v = bytes(v).rstrip(b\"\\x00\")\n            else:\n                v = np.array(v)\n        content[k[0]] = v\n    return content\n</code></pre>"},{"location":"reference/spexread/structdef/#spexread.structdef.ROIInfo","title":"ROIInfo","text":"<p>Structure containing size, position and binning info about a region of interest.</p>"},{"location":"reference/spexread/structdef/#spexread.structdef.ROIInfo._pack_","title":"_pack_","text":"<pre><code>_pack_ = 1\n</code></pre>"},{"location":"reference/spexread/structdef/#spexread.structdef.ROIInfo._fields_","title":"_fields_","text":"<pre><code>_fields_ = [('startx', u16), ('endx', u16), ('groupx', u16), ('starty', u16), ('endy', u16), ('groupy', u16)]\n</code></pre>"},{"location":"reference/spexread/structdef/#spexread.structdef.CalibrationStruct","title":"CalibrationStruct","text":"<p>Structure containing calibration information for a spectrometer.</p>"},{"location":"reference/spexread/structdef/#spexread.structdef.CalibrationStruct._pack_","title":"_pack_","text":"<pre><code>_pack_ = 1\n</code></pre>"},{"location":"reference/spexread/structdef/#spexread.structdef.CalibrationStruct._fields_","title":"_fields_","text":"<pre><code>_fields_ = [\n    (\"offset\", d64),\n    (\"factor\", d64),\n    (\"current_unit\", s8),\n    (\"reserved1\", s8),\n    (\"string\", c_char * 40),\n    (\"reserved2\", s8 * 40),\n    (\"calib_valid\", s8),\n    (\"input_unit\", s8),\n    (\"polynom_unit\", s8),\n    (\"polynom_order\", s8),\n    (\"calib_count\", s8),\n    (\"pixel_position\", d64 * 10),\n    (\"calib_value\", d64 * 10),\n    (\"polynom_coeff\", d64 * 6),\n    (\"laser_position\", d64),\n    (\"reserved3\", s8),\n    (\"new_calib_flag\", u8),\n    (\"calib_label\", c_char * 81),\n    (\"expansion\", s8 * 87),\n]\n</code></pre>"},{"location":"reference/spexread/structdef/#spexread.structdef.SPEInfoHeader","title":"SPEInfoHeader","text":"<p>Info header of legacy SPE files (version <code>2.x</code>) packed as a C Struct.</p> <p>Defined verbatim according to the <code>SPE 3.0 File Format Specification</code> manual which highlights changes between v3.0 and v2.5.</p> <p>This header format is formally defined as the <code>Version 2.5 Header</code> according to the WinSpec manual and should be backwards compatible with previous versions.</p> <p>For older SPE file headers (namely v1.43 and v1.6), there will be minor differences since some blocks have been redefined and/or repurposed between versions.</p> <p>Support for these ancient versions is not guaranteed.</p>"},{"location":"reference/spexread/structdef/#spexread.structdef.SPEInfoHeader._pack_","title":"_pack_","text":"<pre><code>_pack_ = 1\n</code></pre>"},{"location":"reference/spexread/structdef/#spexread.structdef.SPEInfoHeader._fields_","title":"_fields_","text":"<pre><code>_fields_ = [\n    (\"ControllerVersion\", s16),\n    (\"LogicOutput\", s16),\n    (\"AmpHiCapLowNoise\", u16),\n    (\"xDimDet\", u16),\n    (\"mode\", s16),\n    (\"exp_sec\", f32),\n    (\"VChipXdim\", s16),\n    (\"VChipYdim\", s16),\n    (\"yDimDet\", u16),\n    (\"date\", c_char * DATAMAX),\n    (\"VirtualChipFlag\", s16),\n    (\"Spare_1\", c_int8 * 2),\n    (\"noscan\", s16),\n    (\"DetTemperature\", f32),\n    (\"DetType\", s16),\n    (\"xdim\", u16),\n    (\"stdiode\", s16),\n    (\"DelayTime\", f32),\n    (\"ShutterControl\", u16),\n    (\"AbsorbLive\", s16),\n    (\"AbsorpMode\", u16),\n    (\"CanDoVirtualChipFlag\", s16),\n    (\"ThresholdMinLive\", s16),\n    (\"ThresholdMinVal\", f32),\n    (\"ThresholdMaxLive\", s16),\n    (\"ThresholdMaxVal\", f32),\n    (\"SpecAutoSpectroModule\", s16),\n    (\"SpecCenterWlNm\", f32),\n    (\"SpecGlueFlag\", s16),\n    (\"SpecGlueStartWlNm\", f32),\n    (\"SpecGlueEndWlNm\", f32),\n    (\"SpecGlueMinOvrlpNm\", f32),\n    (\"SpecGlueFinalResNm\", f32),\n    (\"PulserType\", s16),\n    (\"CustomChipFlag\", s16),\n    (\"XPrePixels\", s16),\n    (\"XPostPixels\", s16),\n    (\"YPrePixels\", s16),\n    (\"YPostPixels\", s16),\n    (\"asynen\", s16),\n    (\"datatype\", s16),\n    (\"PulserMode\", s16),\n    (\"PulserOnChipAccums\", u16),\n    (\"PulserRepeatExp\", u32),\n    (\"PulseRepWidth\", f32),\n    (\"PulseRepDelay\", f32),\n    (\"PulseSeqStartWidth\", f32),\n    (\"PulseSeqEndWidth\", f32),\n    (\"PulseSeqStartDelay\", f32),\n    (\"PulseSeqEndDelay\", f32),\n    (\"PulseSeqIncMode\", s16),\n    (\"PImaxUsed\", s16),\n    (\"PImaxMode\", s16),\n    (\"PImaxGain\", s16),\n    (\"BackGrndApplied\", s16),\n    (\"PImax2nsBrdUsed\", s16),\n    (\"minblk\", u16),\n    (\"numminblk\", u16),\n    (\"SpecMirrorLocation\", s16 * 2),\n    (\"SpecSlitLocation\", s16 * 4),\n    (\"CustomTimingFlag\", s16),\n    (\"ExperimentTimeLocal\", c_char * TIMEMAX),\n    (\"ExperimentTimeUTC\", c_char * TIMEMAX),\n    (\"ExposUnits\", s16),\n    (\"ADCoffset\", u16),\n    (\"ADCrate\", u16),\n    (\"ADCtype\", u16),\n    (\"ADCresolution\", u16),\n    (\"ADCbitAdjust\", u16),\n    (\"gain\", u16),\n    (\"Comments\", c_char * (5 * COMMENTMAX)),\n    (\"geometric\", u16),\n    (\"xlabel\", c_char * LABELMAX),\n    (\"cleans\", u16),\n    (\"NumSkpPerCln\", u16),\n    (\"SpecMirrorPos\", s16 * 2),\n    (\"SpecSlitPos\", f32 * 4),\n    (\"AutoCleansActive\", s16),\n    (\"UseContCleansInst\", s16),\n    (\"AbsorbStripNum\", s16),\n    (\"SpecSlipPosUnits\", s16),\n    (\"SpecGrooves\", f32),\n    (\"srccmp\", s16),\n    (\"ydim\", u16),\n    (\"scramble\", s16),\n    (\"ContinuousCleansFlag\", s16),\n    (\"ExternalTriggerFlag\", s16),\n    (\"lnoscan\", s32),\n    (\"lavgexp\", s32),\n    (\"ReadoutTime\", f32),\n    (\"TriggeredModeFlag\", s16),\n    (\"XMLOffset\", u64),\n    (\"NotUsed\", u16),\n    (\"sw_version\", c_char * FILEVERMAX),\n    (\"type\", s16),\n    (\"flatFieldApplied\", s16),\n    (\"Spare_3\", c_char * 16),\n    (\"kin_trig_mode\", s16),\n    (\"dlabel\", c_char * LABELMAX),\n    (\"Spare_4\", c_char * 436),\n    (\"PulseFileName\", c_char * HDRNAMEMAX),\n    (\"AbsorbFileName\", c_char * HDRNAMEMAX),\n    (\"NumExpRepeats\", u32),\n    (\"NumExpAccums\", u32),\n    (\"YT_Flag\", s16),\n    (\"clkspd_us\", f32),\n    (\"HWaccumFlag\", s16),\n    (\"StoreSync\", s16),\n    (\"BlemishApplied\", s16),\n    (\"CosmicApplied\", s16),\n    (\"CosmicType\", s16),\n    (\"CosmicThreshold\", f32),\n    (\"NumFrames\", s32),\n    (\"MaxIntensity\", f32),\n    (\"MinIntensity\", f32),\n    (\"ylabel\", c_char * LABELMAX),\n    (\"ShutterType\", u16),\n    (\"shutterComp\", f32),\n    (\"readoutMode\", u16),\n    (\"WindowSize\", u16),\n    (\"clkspd\", u16),\n    (\"interface_type\", u16),\n    (\"NumROIsInExperiment\", s16),\n    (\"Spare_5\", c_char * 16),\n    (\"controllerNum\", u16),\n    (\"SWmade\", u16),\n    (\"NumROI\", s16),\n    (\"ROIinfblk\", ROIInfo * ROIMAX),\n    (\"FlatField\", c_char * HDRNAMEMAX),\n    (\"background\", c_char * HDRNAMEMAX),\n    (\"blemish\", c_char * HDRNAMEMAX),\n    (\"file_header_ver\", f32),\n    (\"YT_Info\", c_char * 1000),\n    (\"WinView_id\", s32),\n    (\"xcalibration\", CalibrationStruct),\n    (\"ycalibration\", CalibrationStruct),\n    (\"Istring\", c_char * 40),\n    (\"Spare_6\", c_char * 25),\n    (\"SpecType\", c_byte),\n    (\"SpecModel\", c_byte),\n    (\"PulseBurstUsed\", c_byte),\n    (\"PulseBurstCount\", u32),\n    (\"PulseBurstPeriod\", d64),\n    (\"PulseBracketUsed\", c_byte),\n    (\"PulseBracketType\", c_byte),\n    (\"PulseTimeConstFast\", d64),\n    (\"PulseAmplitudeFast\", d64),\n    (\"PulseTimeConstSlow\", d64),\n    (\"PulseAmplitudeSlow\", d64),\n    (\"AnalogGain\", s16),\n    (\"AvGainUsed\", s16),\n    (\"AvGain\", s16),\n    (\"lastvalue\", s16),\n]\n</code></pre>"},{"location":"reference/spexread/transformation/","title":"transformation","text":""},{"location":"reference/spexread/transformation/#spexread.transformation","title":"spexread.transformation","text":"<p>Simple transformations of data for rotation and flipping operations.</p> <p>Functions:</p> Name Description <code>Hflip</code> <p>Flip data along horizontal axis.</p> <code>Vflip</code> <p>Flip data along vertical axis.</p> <code>rotate_clockwise</code> <p>Rotate data clockwise by 90 degrees.</p> <code>apply_transformations</code> <p>Apply flip(s) then rotation to axes.</p> <code>transformation_mapping</code> <p>Determine the transformations needed to map from one orientation to another.</p> <code>parse_orientation</code> <p>Parse a string with orientation information, returning a tuple of atomic transformation operations.</p> <code>map_calibration_to_current_coordinate_system</code> <p>Compute the mapping of a wavelength calibration to the current sensor orientation.</p>"},{"location":"reference/spexread/transformation/#spexread.transformation.Hflip","title":"Hflip","text":"<pre><code>Hflip(x, y)\n</code></pre> <p>Flip data along horizontal axis.</p> <p>This causes the x-axis to be inverted.</p> Source code in <code>src/spexread/transformation.py</code> <pre><code>def Hflip(x, y):\n    \"\"\"Flip data along horizontal axis.\n\n    This causes the x-axis to be inverted.\n    \"\"\"\n    return x[::-1], y\n</code></pre>"},{"location":"reference/spexread/transformation/#spexread.transformation.Vflip","title":"Vflip","text":"<pre><code>Vflip(x, y)\n</code></pre> <p>Flip data along vertical axis.</p> <p>This causes the y axis to be inverted.</p> Source code in <code>src/spexread/transformation.py</code> <pre><code>def Vflip(x, y):\n    \"\"\"Flip data along vertical axis.\n\n    This causes the y axis to be inverted.\n    \"\"\"\n    return x, y[::-1]\n</code></pre>"},{"location":"reference/spexread/transformation/#spexread.transformation.rotate_clockwise","title":"rotate_clockwise","text":"<pre><code>rotate_clockwise(x, y)\n</code></pre> <p>Rotate data clockwise by 90 degrees.</p> <p>This swaps the order of the two axes and inverts the order of the y-axis.</p> Source code in <code>src/spexread/transformation.py</code> <pre><code>def rotate_clockwise(x, y):\n    \"\"\"Rotate data clockwise by 90 degrees.\n\n    This swaps the order of the two axes and inverts the order of the y-axis.\n    \"\"\"\n    return y[::-1], x\n</code></pre>"},{"location":"reference/spexread/transformation/#spexread.transformation.apply_transformations","title":"apply_transformations","text":"<pre><code>apply_transformations(x: Any, y: Any, flip_h: bool = False, flip_v: bool = False, rotate: bool = False)\n</code></pre> <p>Apply flip(s) then rotation to axes.</p> <p>This order is consistent with how LightField applies these transformations. It allows for a total of 8 (=2^3) different orientations to be represented by these operations.</p> Source code in <code>src/spexread/transformation.py</code> <pre><code>def apply_transformations(x: Any, y: Any, flip_h: bool = False, flip_v: bool = False, rotate: bool = False):\n    \"\"\"Apply flip(s) then rotation to axes.\n\n    This order is consistent with how LightField applies these transformations.\n    It allows for a total of 8 ($=2^3$) different orientations to be represented by these operations.\n    \"\"\"\n    if flip_h:\n        x, y = Hflip(x, y)\n    if flip_v:\n        x, y = Vflip(x, y)\n    if rotate:\n        x, y = rotate_clockwise(x, y)\n    return x, y\n</code></pre>"},{"location":"reference/spexread/transformation/#spexread.transformation.transformation_mapping","title":"transformation_mapping","text":"<pre><code>transformation_mapping(\n    from_orientation: tuple[bool, bool, bool], to_orientation: tuple[bool, bool, bool]\n) -&gt; tuple[bool, bool, bool]\n</code></pre> <p>Determine the transformations needed to map from one orientation to another.</p> <p>Flip operations use XOR (exclusive or) and rotations are determined from difference.</p> <p>Parameters:</p> Name Type Description Default <code>from_orientation</code> <code>tuple[bool, bool, bool]</code> <p>The current orientation as (flip_h, flip_v, rotate).</p> required <code>to_orientation</code> <code>tuple[bool, bool, bool]</code> <p>The target orientation as (flip_h, flip_v, rotate).</p> required <p>Returns:</p> Type Description <code>tuple[bool, bool, bool]</code> <p>tuple[bool, bool, bool]: The transformations needed as (flip_h, flip_v, rotate).</p> Source code in <code>src/spexread/transformation.py</code> <pre><code>def transformation_mapping(\n    from_orientation: tuple[bool, bool, bool], to_orientation: tuple[bool, bool, bool]\n) -&gt; tuple[bool, bool, bool]:\n    \"\"\"Determine the transformations needed to map from one orientation to another.\n\n    Flip operations use XOR (exclusive or) and rotations are determined from difference.\n\n    Args:\n        from_orientation (tuple[bool, bool, bool]): The current orientation as (flip_h, flip_v, rotate).\n        to_orientation (tuple[bool, bool, bool]): The target orientation as (flip_h, flip_v, rotate).\n\n    Returns:\n        tuple[bool, bool, bool]: The transformations needed as (flip_h, flip_v, rotate).\n    \"\"\"\n    flip_h = from_orientation[0] ^ to_orientation[0]\n    flip_v = from_orientation[1] ^ to_orientation[1]\n    rotate = from_orientation[2] != to_orientation[2]\n    return (flip_h, flip_v, rotate)\n</code></pre>"},{"location":"reference/spexread/transformation/#spexread.transformation.parse_orientation","title":"parse_orientation","text":"<pre><code>parse_orientation(orientation: str) -&gt; tuple[bool, bool, bool]\n</code></pre> <p>Parse a string with orientation information, returning a tuple of atomic transformation operations.</p> Source code in <code>src/spexread/transformation.py</code> <pre><code>def parse_orientation(orientation: str) -&gt; tuple[bool, bool, bool]:\n    \"\"\"Parse a string with orientation information, returning a tuple of atomic transformation operations.\"\"\"\n    return (\"Horiz\" in orientation, \"Vert\" in orientation, \"Rot\" in orientation)\n</code></pre>"},{"location":"reference/spexread/transformation/#spexread.transformation.map_calibration_to_current_coordinate_system","title":"map_calibration_to_current_coordinate_system","text":"<pre><code>map_calibration_to_current_coordinate_system(\n    info: SPEType,\n) -&gt; tuple[Literal[\"x\"] | Literal[\"y\"], ArrayLike, tuple[str, str], tuple[str, str]]\n</code></pre> <p>Compute the mapping of a wavelength calibration to the current sensor orientation.</p> <p>Wavelength calibrations are stored in the SPE file, along with the orientation that was used when it was taken.</p> <p>When transformations are applied to the sensor frames, this information can be used to map the calibration to the new orientation.</p> <p>Note that no guarantee can be made that the calibration in still valid, as this depends also on physical factors.</p> <p>These transformations should be considered best-effort and nothing more than a convenience for the case that they remain valid.</p> Note <p>Without any transformation the order of the data stored on disk is (<code>frame</code>,<code>y</code>,<code>x</code>). For clarity, <code>frame</code> is omitted in transformations, as different orientations don't affect this.</p> <p>Returns:</p> Name Type Description <code>calib_coordinate_name</code> <code>Literal['x'] | Literal['y']</code> <p>The name of the axis that is wavelength calibrated, either \"x\" or \"y\"</p> <code>calibration</code> <code>ArrayLike</code> <p>The array of calibration values for the corresponding axis</p> <code>calibration_order</code> <code>tuple[str, str]</code> <p>The order of the dimensions of the calibration, when it was calibrated, before subsequent transformations.</p> <code>dimension_order</code> <code>tuple[str, str]</code> <p>The order of the dimensions of the frame after applying tranformation.</p> Source code in <code>src/spexread/transformation.py</code> <pre><code>def map_calibration_to_current_coordinate_system(\n    info: \"SPEType\",\n) -&gt; tuple[Literal[\"x\"] | Literal[\"y\"], ArrayLike, tuple[str, str], tuple[str, str]]:\n    \"\"\"Compute the mapping of a wavelength calibration to the current sensor orientation.\n\n    Wavelength calibrations are stored in the SPE file, along with the orientation that was used when it was taken.\n\n    When transformations are applied to the sensor frames, this information can be used to map the calibration to the new orientation.\n\n    Note that no guarantee can be made that the calibration in still valid, as this depends also on physical factors.\n\n    These transformations should be considered best-effort and nothing more than a convenience for the case that they remain valid.\n\n    Note:\n        Without any transformation the order of the data stored on disk is (`frame`,`y`,`x`).\n        For clarity, `frame` is omitted in transformations, as different orientations don't affect this.\n\n    Returns:\n        calib_coordinate_name:      The name of the axis that is wavelength calibrated, either \"x\" or \"y\"\n        calibration:                The array of calibration values for the corresponding axis\n        calibration_order:          The order of the dimensions of the calibration, when it was calibrated, before subsequent transformations.\n        dimension_order:            The order of the dimensions of the frame after applying tranformation.\n    \"\"\"\n    orient_calib = parse_orientation(\n        info.Calibrations.WavelengthCalib.orientation if info.Calibrations.WavelengthCalib is not None else \"Normal\"\n    )\n    # print(f\"{info.Calibrations.WavelengthCalib.orientation} -&gt; {info.Calibrations.SensorInformation.orientation}\")\n\n    orient_current = parse_orientation(info.Calibrations.SensorInformation.orientation)\n    default_order = (\"x\", \"y\")\n    calibration_order = apply_transformations(*default_order, *orient_calib)  #\n    calib_coordinate_name = calibration_order[0]  # Assume calibrated axis is at 0th index\n    coordinate_order_current = apply_transformations(*default_order, *orient_current)  # noqa: F841\n    transform = transformation_mapping(orient_calib, orient_current)\n    calib = apply_transformations(info.Calibrations.wl, np.array([0, 1]), *transform)  # noqa: F841\n    dimension_order = apply_transformations(\"y\", \"x\", *transform)\n    # print(\n    #     f\"{coordinate_order_calib}, {coordinate_order_current}, {coordinate_order_current.index(calib_coordinate_name)}\"\n    # )\n    # return calib_coordinate_name, calib[coordinate_order_current.index(calib_coordinate_name)]\n    return calib_coordinate_name, info.Calibrations.wl, calibration_order, dimension_order\n</code></pre>"}]}